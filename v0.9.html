<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Son Tabak Online - v0.9 (Open Beta)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Google Fonts: Patrick Hand (Comic Sans alternatifi) -->
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <style>
        /* --- TEMEL CSS --- */
        :root {
            --card-pattern: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            --bg-color: #2c3e50;
            --primary: #e67e22;
            --accent: #f1c40f;
            --main-font: 'Patrick Hand', cursive; 
        }

        /* SCROLL FIX */
        body { 
            font-family: 'Segoe UI', sans-serif; 
            background-color: var(--bg-color); 
            color: #333; 
            margin: 0; 
            min-height: 100vh; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            overflow-y: auto; 
            overflow-x: hidden;
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }

        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20000; }
        
        /* --- Gƒ∞Rƒ∞≈û EKRANI --- */
        #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 8000; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; overflow: hidden; }
        
        .floating-bg { position: absolute; font-size: 3rem; opacity: 0.3; bottom: -50px; animation: floatAnim linear infinite; pointer-events: none; z-index: 0; }
        @keyframes floatAnim { 
            0% { transform: translateY(0) rotate(0deg); opacity: 0; } 
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-120vh) rotate(360deg); opacity: 0; } 
        }

        .brand-corner { position: absolute; top: 20px; left: 20px; font-size: 1.5em; font-weight: 900; color: var(--primary); z-index: 10; display: flex; align-items: center; gap: 5px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); font-family: var(--main-font); }
        .production-corner { position: absolute; bottom: 10px; left: 20px; font-size: 0.7em; color: rgba(255,255,255,0.4); z-index: 10; letter-spacing: 1px; }
        .rules-corner { position: absolute; top: 20px; right: 20px; z-index: 9000; }
        .icon-btn { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5em; cursor: pointer; color: white; display: flex; align-items: center; justify-content: center; transition: 0.3s; }
        .icon-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }

        .login-content { position: relative; z-index: 5; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; }
        .logo-container { position: relative; margin-bottom: 20px; }
        .plate-anim { font-size: 6em; animation: plateWobble 3s infinite ease-in-out; display: block; filter: drop-shadow(0 10px 10px rgba(0,0,0,0.3)); }
        @keyframes plateWobble { 0%, 100% { transform: rotate(-5deg); } 50% { transform: rotate(5deg); } }
        
        .game-title-login { font-size: 3em; font-weight: 900; margin-top: -10px; color: white; text-shadow: 0 4px 0 #000; letter-spacing: -2px; line-height: 1; font-family: var(--main-font); }
        .online-stamp { position: absolute; top: 0; right: -30px; background: #c0392b; color: white; padding: 2px 8px; font-size: 0.4em; font-weight: bold; transform: rotate(30deg); border: 2px solid white; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); animation: stampPulse 2s infinite; font-family: sans-serif; }
        @keyframes stampPulse { 0% { transform: rotate(30deg) scale(1); } 50% { transform: rotate(30deg) scale(1.1); } 100% { transform: rotate(30deg) scale(1); } }

        .login-input-group { background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); padding: 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 50px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 15px; width: 300px; max-width: 90%; }
        .styled-input { background: rgba(0,0,0,0.3); border: none; padding: 15px; border-radius: 10px; color: white; font-size: 1.1em; text-align: center; outline: none; transition: 0.3s; border: 1px solid transparent; width: 100%; box-sizing: border-box; }
        .styled-input:focus { background: rgba(0,0,0,0.5); border-color: var(--primary); }
        .login-btn-main { background: var(--primary); color: white; border: none; padding: 15px; border-radius: 10px; font-size: 1.2em; font-weight: bold; cursor: pointer; transition: 0.3s; box-shadow: 0 5px 0 #d35400; width: 100%; font-family: var(--main-font); }
        .login-btn-main:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #d35400; }
        .login-btn-main:active { transform: translateY(2px); box-shadow: 0 2px 0 #d35400; }

        /* --- LOBƒ∞ EKRANI --- */
        #lobby-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-color); z-index: 7500; display: none; flex-direction: column; padding: 60px 20px 20px 20px; box-sizing: border-box; overflow: hidden; }
        
        .lobby-grid { display: grid; grid-template-columns: 1fr 1.6fr 0.8fr; gap: 15px; height: 100%; width: 100%; max-width: 1400px; margin: 0 auto; grid-template-rows: 1fr 200px; }
        
        .lobby-col { background: rgba(255,255,255,0.95); border-radius: 15px; padding: 15px; display: flex; flex-direction: column; box-shadow: 0 10px 30px rgba(0,0,0,0.2); overflow: hidden; position: relative; transition: all 0.3s ease; }
        .col-title { font-size: 1.2em; font-weight: 800; color: #2c3e50; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #eee; display: flex; justify-content: space-between; align-items: center; user-select: none; }
        
        .create-form { display: flex; flex-direction: column; gap: 10px; }
        .mode-check { display: flex; align-items: center; gap: 10px; background: #f9f9f9; padding: 10px; border-radius: 8px; margin-top: 5px; cursor: pointer; border: 1px solid #eee; }

        .room-scroll { overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 8px; }
        .lobby-room-item { background: white; border: 1px solid #eee; padding: 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; transition: 0.2s; }
        .lobby-room-item:hover { transform: translateX(3px); border-color: #bdc3c7; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .room-status-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; }
        .st-green { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .st-yellow { background: #f1c40f; box-shadow: 0 0 5px #f1c40f; }
        .st-red { background: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
        .room-info { display: flex; align-items: center; flex: 1; }
        .room-name-txt { font-weight: bold; color: #333; margin-right: 10px; }
        .room-count-pill { font-size: 0.8em; background: #eee; padding: 2px 6px; border-radius: 4px; color: #555; }
        .room-action-btn { padding: 6px 15px; font-size: 0.9em; border-radius: 6px; cursor: pointer; border: none; background: #3498db; color: white; font-weight: bold; }
        .room-action-btn:hover { background: #2980b9; }

        .lobby-col.players-col { grid-column: 3; grid-row: 1 / span 2; }
        .player-list-scroll { overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 4px; }

        /* LOBBY CHAT & PLAYERS LIST STYLES */
        .lobby-chat-wrapper { 
            grid-column: 1 / 3; 
            background: rgba(255,255,255,0.95); 
            border-radius: 15px; 
            padding: 10px; 
            display: flex; 
            flex-direction: column; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
        }

        #lobby-chat-msgs {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #eee;
            background: #fdfdfd;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 5px;
            font-size: 0.85em;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .l-chat-line { padding: 2px 4px; border-bottom: 1px dashed #f0f0f0; word-break: break-word; }
        .l-chat-input-area { display: flex; gap: 5px; height: 35px; }
        #l-chat-input { flex: 1; border: 1px solid #ccc; border-radius: 15px; padding: 0 10px; font-size: 0.9em; outline: none; }
        #l-chat-send { background: #27ae60; color: white; border: none; width: 40px; border-radius: 50%; font-size: 1.2em; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        
        /* Players List Item Styles */
        .p-list-item { 
            display: flex; align-items: center; padding: 4px 8px; border-bottom: 1px solid #f5f5f5; font-size: 0.85em; color: #555; background: white; border-radius: 4px;
        }
        .p-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; flex-shrink: 0; }
        .p-dot-lobby { background: #2ecc71; box-shadow: 0 0 4px #2ecc71; }
        .p-dot-wait { background: #f1c40f; box-shadow: 0 0 4px #f1c40f; }
        .p-dot-play { background: #e74c3c; box-shadow: 0 0 4px #e74c3c; }

        /* --- OYUN ALANI D√úZENƒ∞ --- */
        #main-game-wrapper { display: none; }
        .main-wrapper { 
            display: grid; width: 98%; max-width: 1400px; height: auto; min-height: 98vh; gap: 10px; padding: 5px; box-sizing: border-box; 
            grid-template-columns: 1fr 300px; grid-template-rows: auto 1fr auto; 
            grid-template-areas: "game logo" "game panel" "game buttons"; 
        }

        #brand-area { grid-area: logo; text-align: center; background: #fff; padding: 10px; border-radius: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: center; height: fit-content; }
        .brand-title { font-size: 1.5em; font-weight: 900; color: #2c3e50; line-height: 1; font-family: var(--main-font); }
        .version { font-size: 0.4em; color: #95a5a6; margin-left: 5px; font-weight: normal; font-family: sans-serif; }
        .brand-sub { font-size: 0.7em; margin: 0; margin-left: auto; color: var(--primary); font-weight: 800; }

        .right-panel { grid-area: panel; display: flex; flex-direction: column; gap: 10px; height: 100%; overflow: hidden; }
        
        .info-container { background: #fff; width: 100%; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.2); overflow: hidden; display: flex; flex-direction: column; height: 200px; }
        
        .panel-header { font-weight: bold; color: #fff; background: #34495e; padding: 5px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; padding-left: 10px; padding-right: 10px;}
        
        #score-table { width: 100%; font-size: 0.85em; border-collapse: collapse; margin-top: 5px; table-layout: fixed; }
        #score-table td { padding: 4px 6px; border-bottom: 1px solid #eee; text-align: left; vertical-align: middle; font-size: 0.9em; }
        .me-row { background-color: #fff9c4; font-weight: bold; border-left: 4px solid #f1c40f; }

        .chat-container { background: #fff; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.2); flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; height: 300px; }
        #chat-messages { flex-grow: 1; overflow-y: auto; padding: 10px; font-size: 0.85em; display: flex; flex-direction: column; gap: 4px; background: #fcfcfc; text-align: left;}
        .chat-line { line-height: 1.4; border-bottom: 1px solid #eee; padding-bottom: 2px;}
        .chat-input-area { display: flex; padding: 5px; border-top: 1px solid #eee; box-sizing: border-box; width: 100%; }
        #player-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 20px; padding: 5px 10px; font-size: 0.8em; outline: none; min-width: 0; }
        #send-btn { background: #3498db; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; margin-left: 5px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 1.2em; flex-shrink: 0; }

        .game-container { grid-area: game; background: #ecf0f1; border-radius: 20px; box-shadow: 0 15px 40px rgba(0,0,0,0.7); display: grid; grid-template-rows: auto 1fr auto; align-items: center; justify-items: center; position: relative; overflow: hidden; padding: 10px 0; background-color: #fdfbf7; background-image: repeating-linear-gradient(90deg, transparent, transparent 50px, rgba(231, 76, 60, 0.10) 50px, rgba(231, 76, 60, 0.10) 100px), repeating-linear-gradient(0deg, transparent, transparent 50px, rgba(231, 76, 60, 0.10) 50px, rgba(231, 76, 60, 0.10) 100px); transition: box-shadow 0.5s; border: 4px solid transparent; height: 100%; min-height: 600px; }
        .ambient-red { box-shadow: inset 0 0 60px rgba(231, 76, 60, 0.4) !important; border-color: #c0392b !important; }
        .ambient-green { box-shadow: inset 0 0 60px rgba(46, 204, 113, 0.4) !important; border-color: #27ae60 !important; }
        .ambient-yellow { box-shadow: inset 0 0 60px rgba(241, 196, 15, 0.4) !important; border-color: #f39c12 !important; }
        .ambient-purple { box-shadow: inset 0 0 60px rgba(142, 68, 173, 0.4) !important; border-color: #8e44ad !important; }
        
        #top-area { display: grid; grid-template-columns: 1fr auto 1fr auto 1fr; align-items: center; justify-items: center; width: 95%; padding-top: 10px; min-height: 140px; position: relative; z-index: 5; grid-row: 1; align-self: start; }
        .bot-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; width: 100px; position: relative; transition: 0.3s; }
        .bot-name { background: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 0.8em; z-index: 5; margin-bottom: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: 0.3s; white-space: nowrap; border: 1px solid #ddd; }
        .current-player .bot-name { background: #3498db; color: white; box-shadow: 0 0 10px #3498db; transform: scale(1.1); border-color: #2980b9; }
        .chat-bubble { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; border: 2px solid #333; padding: 5px 8px; border-radius: 8px; font-size: 0.7em; font-weight: bold; white-space: normal; width: 120px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.4); z-index: 300; opacity: 0; pointer-events: none; line-height: 1.1; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s; }
        .chat-bubble.visible { opacity: 1; }
        .bot-stack-visual { position: relative; height: 90px; width: 100px; margin-top: 5px; transition: width 0.3s; display: flex; justify-content: center; }
        
        .mini-card-back { width: 60px; height: 90px; border: 3px solid #fff; border-radius: 8px; position: absolute; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); background-size: cover; background-position: center; box-sizing: border-box; display: flex; justify-content: center; align-items: center; overflow: hidden; transition: all 0.3s; background: var(--card-pattern) !important; }
        .card-back-style { background: var(--card-pattern) !important; background-size: cover; border: 3px solid #fff !important; }
        
        /* Centered Text for Card Backs - FONT FIX UYGULANDI */
        .mini-card-back::after, .card-back-style::after { 
            content: "SON\A TABAK"; 
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            color: #3498db; 
            font-family: var(--main-font); 
            font-weight: 900; 
            font-size: 1.1em; 
            white-space: pre; 
            text-align: center; 
            line-height: 0.9; 
            pointer-events: none; 
            text-shadow: 2px 2px 0 #fff; 
        }
        .mini-card-back::after { font-size: 0.75em; transform: translate(-50%, -50%) rotate(-15deg) scale(0.8); }
        
        .arrow-icon { font-size: 2.5em; color: #bdc3c7; font-weight: 900; transition: all 0.5s; z-index: 10; position: absolute; top: 50%; transform: translateY(-50%); opacity: 1; }
        .arrow-icon.active { animation: pulseArrow 2s infinite; text-shadow: 0 0 20px currentColor; z-index: 20; }
        .arrow-top-static { position: static; margin: 0 15px; font-size: 2.5em; color: #bdc3c7; font-weight: 900; transition: all 0.3s; display: inline-block; transform-origin: center; transform: scale(1); }
        .arrow-top-static.active { animation: pulseArrowStatic 1.2s infinite ease-in-out; text-shadow: 0 0 20px currentColor; color: #3498db; }
        @keyframes pulseArrow { 0% { transform: translateY(-50%) scale(1.0); } 50% { transform: translateY(-50%) scale(1.25); } 100% { transform: translateY(-50%) scale(1.0); } }
        @keyframes pulseArrowStatic { 0% { transform: scale(1.0); } 50% { transform: scale(1.3); } 100% { transform: scale(1.0); } }
        .arrow-spin { animation: spinArrow 1.2s ease-in-out forwards !important; }
        @keyframes spinArrow { 0% { transform: translateY(-50%) rotate(0deg) scale(1); } 50% { transform: translateY(-50%) rotate(180deg) scale(1.4); color: #e74c3c; } 100% { transform: translateY(-50%) rotate(360deg) scale(1); } }
        .glow-red { color: #c0392b !important; } .glow-green { color: #27ae60 !important; } .glow-yellow { color: #f1c40f !important; } .glow-purple { color: #9b59b6 !important; } .glow-neutral { color: #3498db !important; }
        #arrow-left { left: 25px; } #arrow-right { right: 25px; } 
        
        #play-area { display: flex; align-items: center; justify-content: center; gap: 80px; width: 100%; min-height: 180px; position: relative; transition: transform 0.3s; z-index: 5; grid-row: 2; align-self: center; }
        .card { width: 105px; height: 155px; border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; font-weight: bold; cursor: pointer; border: 3px solid #555; box-shadow: 5px 5px 15px rgba(0,0,0,0.2); background-color: white; position: relative; user-select: none; transition: transform 0.2s; box-sizing: border-box; flex-shrink: 0; }
        #draw-pile.card:hover { transform: none; }
        .playable:hover { transform: translateY(-30px) scale(1.1); z-index: 100; }
        .playable { border-color: #333; } 
        .card-corner { position: absolute; font-size: 1.2em; margin: 5px; }
        .top-left { top: 2px; left: 2px; } .bottom-right { bottom: 2px; right: 2px; transform: rotate(180deg); }
        .card-emoji { font-size: 4.5em; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
        
        /* FIX +2 CARD LAYOUT (PC MODE) */
        .card[data-val="+2"] .card-emoji { 
            font-size: 2.2em !important; 
            letter-spacing: -2px !important;
            line-height: 1; 
            padding: 0; 
            white-space: nowrap !important;
            display: flex !important; 
            flex-direction: row !important;
            justify-content: center; 
            align-items: center; 
            gap: 2px !important; 
            width: 100%; 
            overflow: visible;
        }

        .guvec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 0.45em; line-height: 1; }
        .red { background-color: #ffcdd2; color: #c0392b; border-color: #c0392b; } .green { background-color: #c8e6c9; color: #27ae60; border-color: #27ae60; } .yellow { background-color: #fff9c4; color: #f39c12; border-color: #f39c12; } .purple { background-color: #e1bee7; color: #8e44ad; border-color: #8e44ad; }
        .wild-bg { background: conic-gradient(from 45deg, #e74c3c, #f1c40f, #2ecc71, #9b59b6, #e74c3c); border: 3px solid #fff; color: #fff; }
        #penalty-badge { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 900; font-size: 1.2em; color: white; width: 40px; height: 40px; border-radius: 50%; border: 3px solid white; display: none; justify-content: center; align-items: center; z-index: 70; transition: all 0.3s; animation: pulseBadge 1s infinite; text-shadow: 1px 1px 0 rgba(0,0,0,0.5); }
        #penalty-badge.p-1 { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; } 
        #penalty-badge.p-2 { background: #f1c40f; box-shadow: 0 0 10px #f1c40f; } 
        #penalty-badge.p-3 { background: #e67e22; box-shadow: 0 0 15px #e67e22; } 
        #penalty-badge.p-4 { background: #e74c3c; box-shadow: 0 0 20px #e74c3c; transform: scale(1.1); } 
        #penalty-badge.p-5 { background: #9b59b6; box-shadow: 0 0 20px #9b59b6; transform: scale(1.15); } 
        #penalty-badge.p-6 { background: #2c3e50; box-shadow: 0 0 25px #000; transform: scale(1.2); } 
        @keyframes pulseBadge { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.15); } 100% { transform: translate(-50%, -50%) scale(1); } }
        
        #bottom-area { width: 100%; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; margin-bottom: 10px; position: relative; z-index: 10; grid-row: 3; align-self: end; }
        #son-tabak-container { margin-bottom: 5px; z-index: 10; display:flex; gap:10px; }
        #son-tabak-btn, #challenge-btn { padding: 12px 30px; border: none; border-radius: 30px; font-size: 1.2em; font-weight: bold; cursor: pointer; color: white; box-shadow: 0 5px 0 rgba(0,0,0,0.2); transition: 0.2s; font-family: var(--main-font); }
        #son-tabak-btn { background-color: #e67e22; } #challenge-btn { background-color: #f1c40f; color: #333; }
        #son-tabak-btn:disabled, #challenge-btn:disabled { background-color: #bdc3c7; box-shadow: none; cursor: not-allowed; opacity: 0.6; color:#fff; }
        #player-hand { display: flex; flex-wrap: wrap; justify-content: center; align-content: center; align-items: center; gap: 8px; width: 90%; padding: 10px; height: auto; min-height: 160px; border: 2px dashed rgba(0,0,0,0.1); border-radius: 25px; overflow: visible; transition: all 0.3s; }
        .current-player-area { border: 4px dashed #3498db !important; background: rgba(255, 255, 255, 0.4) !important; box-shadow: 0 0 20px rgba(52, 152, 219, 0.5); }
        .hand-normal .card { width: 105px; height: 155px; }
        .hand-packed .card { width: 80px; height: 120px; font-size: 0.8em; border-width: 2px; } .hand-packed .card-emoji { font-size: 2.5em; }
        .hand-super-packed .card { width: 60px; height: 90px; font-size: 0.6em; border-width: 2px; } .hand-super-packed .card-emoji { font-size: 1.8em; }
        
        .buttons-container { grid-area: game buttons; display: flex; flex-direction: column; gap: 8px; margin-top: auto; padding: 5px; }
        .game-btn { padding: 12px 20px; border: none; border-radius: 10px; font-size: 1em; font-weight: bold; cursor: pointer; color: white; width: 100%; margin-bottom: 0; transition: 0.2s; font-family: var(--main-font); }
        .game-btn:hover { transform: translateY(-2px); box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
        .btn-red { background-color: #c0392b; } .btn-blue { background-color: #3498db; } .btn-dark { background-color: #34495e; } .btn-green { background-color: #27ae60; }
        
        .flying-card { position: fixed; z-index: 3000; pointer-events: none; transition: all 1.0s ease-in-out; }
        .blocked-anim { position: absolute; font-size: 4em; color: #c0392b; z-index: 300; text-shadow: 0 0 20px #fff; animation: fadeUp 2s forwards; pointer-events: none; transform: translate(-50%, -50%); }
        @keyframes fadeUp { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 80% { opacity: 1; } 100% { opacity: 0; transform: translate(-50%, -100px); } }
        .mixer-container { position: absolute; top: 50%; left: 50%; width: 0; height: 0; z-index: 4000; pointer-events: none; }
        .mixer-card { position: absolute; width: 70px; height: 100px; border: 3px solid #fff; border-radius: 8px; background-size: cover; background-position: center; box-shadow: 0 0 10px rgba(0,0,0,0.5); transform-origin: center 250px; top: -300px; left: -35px; background: var(--card-pattern) !important; }
        .mixer-card::after { 
            content: "SON\A TABAK"; 
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%) rotate(-15deg); 
            color: #3498db; 
            font-weight: 900; 
            font-size: 0.75em; 
            white-space: pre; 
            text-align: center; 
            line-height:0.9; 
            font-family: var(--main-font); 
        }
        
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 9999; }
        .modal-box { background: white; padding: 30px; border-radius: 20px; text-align: center; width: 80%; max-width: 320px; height: auto; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .color-picker { display: flex; justify-content: center; gap: 15px; margin-top: 15px; flex-wrap: wrap; }
        .color-opt { width: 50px; height: 50px; border-radius: 50%; border: 4px solid #333; cursor: pointer; transition: 0.2s; flex-shrink: 0; }
        .bg-red { background: #e74c3c; } .bg-green { background: #2ecc71; } .bg-yellow { background: #f1c40f; } .bg-purple { background: #9b59b6; }
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; }
        .pattern-opt { width: 50px; height: 70px; border: 2px solid #ccc; cursor: pointer; background-size: cover; position: relative; }
        .pattern-opt::after { content: "SON"; position: absolute; transform: rotate(-15deg) scale(0.5); color: #3498db; font-weight: 900; top: 35%; left: 5px; text-shadow: 1px 1px 0 white; font-family: var(--main-font); }
        #son-tabak-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #e67e22; color: white; padding: 30px 60px; font-size: 2.5em; font-weight: bold; border-radius: 25px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border: 6px solid white; display: none; z-index: 6000; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); text-align: center; width: auto; max-width: 90%; font-family: var(--main-font); }
        .popup-sub { font-size: 0.6em; display: block; margin-top: 10px; font-weight: normal; }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }
        #challenge-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 25px 50px; font-size: 2em; font-weight: bold; border-radius: 20px; box-shadow: 0 0 40px rgba(0,0,0,0.7); border: 5px solid white; display: none; z-index: 6000; animation: popIn 0.3s ease-out; text-align: center; width: auto; max-width: 90%; font-family: var(--main-font); }
        .challenge-valid { background-color: #27ae60; } .challenge-invalid { background-color: #c0392b; }
        .challenge-sub { font-size: 0.6em; display: block; margin-top: 5px; font-weight: normal; opacity: 0.9; }
        #leave-modal .modal-box { border: 4px solid #c0392b; }
        #mixer-info { font-size: 0.85em; background: #ecf0f1; padding: 10px; border-radius: 8px; margin: 10px 0; text-align: left; }
        
        /* --- NEW LOUNGE STYLES --- */
        #leave-modal { z-index: 10005 !important; } /* Fix Z-Index */

        .wr-container { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .wr-header { background: #e67e22; color: white; padding: 10px 20px; border-radius: 15px; width: 100%; box-sizing: border-box; box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4); }
        .wr-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; margin: 15px 0; }
        .wr-card { 
            background: #f9f9f9; border: 2px solid #eee; border-radius: 15px; padding: 15px 10px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: all 0.3s ease; position: relative; overflow: hidden;
        }
        .wr-card.active { border-color: #3498db; background: #ebf5fb; box-shadow: 0 5px 15px rgba(52, 152, 219, 0.2); }
        .wr-card.host-card { border-color: #f1c40f; background: #fef9e7; }
        .wr-avatar { 
            width: 50px; height: 50px; border-radius: 50%; display: flex; justify-content: center; align-items: center; 
            font-size: 1.5em; margin-bottom: 5px; color: white; box-shadow: 0 3px 6px rgba(0,0,0,0.1); 
            animation: bounceIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes bounceIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .wr-name { font-weight: bold; font-size: 0.9em; color: #34495e; }
        .wr-role { font-size: 0.7em; color: #95a5a6; margin-top: 2px; }
        .wr-status { position: absolute; top: 5px; right: 5px; width: 10px; height: 10px; border-radius: 50%; background: #ccc; }
        .wr-status.ready { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .host-crown { position: absolute; top: -5px; left: -5px; font-size: 1.2em; transform: rotate(-15deg); }

        /* MOBILE OPTIMIZATION */
        @media screen and (max-width: 900px) {
            body { 
                /* Mobile specific tweaks, but keep scroll capability */
                min-height: 100vh;
                background: #2c3e50; 
            }
            #login-overlay { padding: 20px; box-sizing: border-box; }
            .login-input-group { width: 90% !important; padding: 25px; }
            .game-title-login { font-size: 2.2em; }
            .plate-anim { font-size: 4em; }
            .brand-corner { font-size: 1.2em; top: 10px; left: 10px; }
            .production-corner { font-size: 0.6em; bottom: 5px; left: 10px; }
            
            #lobby-overlay { overflow-y: auto; padding: 50px 10px 10px 10px; display: none; }
            
            /* UPDATED MOBILE LOBBY GRID */
            .lobby-grid { 
                display: flex; 
                flex-direction: row;
                flex-wrap: wrap; 
                height: auto; 
                gap: 10px; 
                padding-bottom: 20px; 
                align-items: flex-start;
            }
            
            /* Full width for Top Columns (Create & Active Rooms) */
            #col-create, #col-rooms { 
                width: 100%; 
                box-sizing: border-box; 
                min-height: auto; 
                max-height: 50px; 
                flex: none; 
                padding: 10px 15px; 
                overflow: hidden; 
                cursor: pointer; 
            }
            #col-create.open-tab, #col-rooms.open-tab { 
                max-height: 500px; 
                cursor: default; 
                padding: 15px; 
            }
            
            /* FIX: Side-by-Side Players & Chat */
            .lobby-col.players-col {
                width: calc(50% - 6px); 
                flex: none;
                height: 250px; 
                max-height: 250px !important; 
                padding: 5px !important;
                margin: 0;
                display: flex;
                flex-direction: column;
                cursor: default !important;
                box-sizing: border-box;
            }

            .lobby-chat-wrapper { 
                width: calc(50% - 6px); 
                box-sizing: border-box; 
                height: 250px; 
                flex: none;
                margin: 0;
                font-size: 0.8em; 
            }

            /* Adjust internal elements for Players & Chat */
            .lobby-col.players-col .col-content {
                opacity: 1 !important; /* Always visible */
                pointer-events: auto !important;
            }
            .lobby-col.players-col .col-title::after {
                display: none; /* Remove accordion arrow */
            }
            #l-chat-input { width: 100%; box-sizing: border-box; }
            .l-chat-input-area { width: 100%; }

            /* Accordion Titles for top items */
            .col-title { margin-bottom: 0; border-bottom: none; font-size: 1em; cursor: pointer; }
            #col-create.open-tab .col-title, #col-rooms.open-tab .col-title { margin-bottom: 15px; border-bottom: 2px solid #eee; }
            .col-title::after { content: '‚ñº'; display: block; font-size: 0.8em; color: #7f8c8d; transition: transform 0.3s; }
            #col-create.open-tab .col-title::after, #col-rooms.open-tab .col-title::after { transform: rotate(180deg); }
            
            .col-content { opacity: 0; transition: opacity 0.3s; pointer-events: none; }
            #col-create.open-tab .col-content, #col-rooms.open-tab .col-content { opacity: 1; pointer-events: auto; }
            
            .styled-input, .p-count-btn, .mode-check { font-size: 0.85em !important; padding: 8px !important; }
            .lobby-room-item { padding: 8px; font-size: 0.85em; }
            .room-action-btn { padding: 5px 10px; font-size: 0.8em; }
            .room-scroll, .player-list-scroll { max-height: 200px; }
            
            .main-wrapper { 
                display: grid; 
                grid-template-columns: 100%; 
                grid-template-rows: 40px 1fr 120px 40px; 
                grid-template-areas: "logo" "game" "panel" "buttons"; 
                width: 100%; 
                min-height: 100vh;
                height: auto; 
                padding: 5px; 
                gap: 5px; 
                box-sizing: border-box; 
            }
            
            #brand-area { grid-area: logo; padding: 4px 8px; flex-direction: row; align-items: center; gap: 5px; border-radius: 10px; margin: 0; height: 100%; box-sizing: border-box; }
            .brand-title { font-size: 1.1em; display: flex; gap: 5px; } 
            .version { font-size: 0.6em; margin: 0; align-self: center; } 
            .brand-sub { font-size: 0.7em; margin: 0; margin-left: auto; }
            .game-container { grid-area: game; width: 100%; height: 100%; min-height: 0; display: flex; flex-direction: column; justify-content: space-between; align-items: center; margin: 0; padding: 5px 0; overflow: hidden; box-sizing: border-box; }
            #top-area { height: auto; min-height: 80px; width: 100%; transform: scale(0.80); transform-origin: center top; margin: 0; }
            #play-area { height: auto; width: 100%; transform: scale(0.80); margin: 0; flex-grow: 1; }
            #bottom-area { padding-bottom: 2px; transform: scale(0.85); transform-origin: center bottom; margin: 0; }
            .bot-wrapper { transform: scale(0.85); margin: 0; } 
            .arrow-icon { font-size: 1.5em; position: absolute; top: 50%; transform: translateY(-50%); z-index: 15; }
            #arrow-left { left: 5px; } #arrow-right { right: 5px; } #arrow-top-1, #arrow-top-2 { font-size: 1.5em; margin: 0; }
            .flying-card { transform: scale(0.8); transform-origin: top left; }
            
            .card[data-val="+2"] .card-emoji { font-size: 2.0em !important; gap: 1px !important; }
            
            #player-hand { min-height: 80px; padding: 4px; gap: 3px; border-width: 2px; }
            .hand-normal .card, .hand-packed .card, .hand-super-packed .card { width: 40px; height: 60px; font-size: 0.5em; border-width: 1px; border-radius: 4px; }
            .hand-normal .card-emoji, .hand-packed .card-emoji, .hand-super-packed .card-emoji { font-size: 1.6em; }
            #son-tabak-btn, #challenge-btn { padding: 8px 15px; font-size: 0.9em; margin-bottom: 2px; }
            #son-tabak-popup, #challenge-popup { position: fixed !important; transform: translate(-50%, -50%) scale(0.7); }
            .right-panel { grid-area: panel; flex-direction: row; height: 100%; gap: 5px; padding: 0; box-sizing: border-box; overflow: hidden; }
            .info-container { height: 100%; flex: 1; }
            .chat-container { height: 100%; flex: 1; }
            #score-table td { padding: 2px 4px; font-size: 0.7em; }
            #chat-messages { font-size: 0.65em !important; padding: 2px !important; gap: 1px !important; }
            .chat-line { line-height: 1.1 !important; margin-bottom: 2px !important; }
            .panel-header { font-size: 0.75em; padding: 3px; }
            .chat-input-area { padding: 2px; }
            #player-input { font-size: 0.7em; padding: 2px 5px; height: 25px; }
            #send-btn { width: 25px; height: 25px; font-size: 1em; }
            .buttons-container { grid-area: buttons; flex-direction: row; gap: 5px; padding: 0; box-sizing: border-box; height: 100%; margin: 0; min-height: 40px; z-index: 100; }
            .game-btn { font-size: 0.8em; padding: 0; display: flex; align-items: center; justify-content: center; height: 100%; flex: 1; margin: 0; }
        }
    </style>
</head>
<body>
<canvas id="confetti-canvas"></canvas>

<div id="login-overlay">
    <div class="brand-corner">üî• Kalority</div>
    <div class="rules-corner"><button class="icon-btn" onclick="openRules()">üìñ</button></div>
    <div class="production-corner">ONR Studios Production</div>

    <div class="floating-bg" style="left:10%; animation-duration:12s; animation-delay: -5s;">üçÖ</div>
    <div class="floating-bg" style="left:30%; animation-duration:15s; animation-delay: -2s;">ü•î</div>
    <div class="floating-bg" style="left:60%; animation-duration:10s; animation-delay: -8s;">üçÜ</div>
    <div class="floating-bg" style="left:80%; animation-duration:14s; animation-delay: -1s;">ü•¶</div>

    <div class="login-content">
        <div class="logo-container">
            <span class="plate-anim">üçΩÔ∏è</span>
            <div class="game-title-login">SON<br>TABAK</div>
            <div class="online-stamp">ONLINE</div>
        </div>
        <div class="login-input-group">
            <input type="text" id="username-in" class="styled-input" placeholder="Adƒ±nƒ± Yaz" maxlength="12">
            <button class="login-btn-main" id="login-btn">Mutfaƒüa Gir</button>
        </div>
    </div>
</div>

<div id="lobby-overlay">
    <div class="brand-corner" style="position:fixed; top:15px; left:20px;">üî• Kalority</div>
    <div class="rules-corner" style="position:fixed; top:15px; right:20px;"><button class="icon-btn" style="background:#333;" onclick="openRules()">üìñ</button></div>
    <div class="production-corner" style="position:fixed; bottom:10px; left:20px; color:#555;">ONR Studios Production</div>

    <div class="lobby-grid">
        <div class="lobby-col" id="col-create">
            <div class="col-title" onclick="toggleLobbyTab(this)">Masa A√ß üõãÔ∏è</div>
            <div class="col-content create-form">
                <input type="text" id="room-name-in" class="styled-input" style="background:#f9f9f9; color:#333; border:1px solid #ddd; text-align:left;" placeholder="Masa Adƒ±">
                <input type="password" id="room-pass-in" class="styled-input" style="background:#f9f9f9; color:#333; border:1px solid #ddd; text-align:left;" placeholder="≈ûifre (Opsiyonel)">
                
                <label class="mode-check" style="cursor: pointer; opacity: 1;">
                    <input type="checkbox" id="offline-mode-check">
                    <span style="font-size:0.9em; font-weight:bold; color:#555;">Tek Ki≈üilik Masa (Offline)</span>
                </label>

                <button class="login-btn-main" id="create-room-btn" style="padding:10px; margin-top:10px;">Masayƒ± Kur</button>
            </div>
        </div>

        <div class="lobby-col open-tab" id="col-rooms">
            <div class="col-title" onclick="toggleLobbyTab(this)">Aktif Masalar üçΩÔ∏è</div>
            <div class="col-content room-scroll" id="room-list">
                <div style="text-align:center; color:#777; margin-top:20px;">Masalar aranƒ±yor...</div>
            </div>
        </div>

        <div class="lobby-col players-col open-tab" id="col-players">
            <div class="col-title">Mutfaktakiler üë®‚Äçüç≥</div>
            <div class="col-content player-list-scroll" id="online-player-list">
                <div style="text-align:center; color:#777; font-size:0.8em; padding:10px;">Y√ºkleniyor...</div>
            </div>
        </div>

        <div class="lobby-chat-wrapper">
            <div style="font-weight:bold; font-size:0.9em; color:#555; margin-bottom:5px; display:flex; justify-content:space-between;">
                <span>Lobi Sohbeti üí¨</span>
            </div>
            <div id="lobby-chat-msgs"></div>
            <div class="l-chat-input-area">
                <input type="text" id="l-chat-input" placeholder="Bir ≈üeyler yaz..." maxlength="50" onkeypress="if(event.key === 'Enter') sendLobbyMessage()">
                <button id="l-chat-send" onclick="sendLobbyMessage()">‚û§</button>
            </div>
        </div>
    </div>
</div>

<div id="waiting-room-overlay" class="modal">
    <div class="modal-box" style="max-width: 500px; width: 90%; background: #fff;">
        <div class="wr-container">
            <div class="wr-header">
                <h3 id="wr-room-name" style="margin:0; font-size:1.2em;">Masa Bekleniyor</h3>
                <span style="font-size:0.8em; opacity:0.8;">Host'un ba≈ülatmasƒ± bekleniyor...</span>
            </div>
            
            <div class="wr-grid" id="wr-player-grid">
                </div>

            <div id="wr-host-controls" style="display:none; width:100%;">
                <p style="font-size:0.8em; color:#e67e22; margin:5px 0;">Eksik oyuncular yerine Bot (ü§ñ) eklenecek.</p>
                <button class="game-btn btn-blue" id="start-game-btn">Oyunu Ba≈ülat üöÄ</button>
            </div>
            <div id="wr-guest-controls" style="width:100%; text-align:center;">
                <p style="color:#7f8c8d; font-size:0.9em;">Masa sahibi bekleniyor... ‚è≥</p>
            </div>
            
            <button class="game-btn btn-red" id="leave-room-btn" style="width:50%; margin-top:10px;">Masadan Ayrƒ±l</button>
        </div>
    </div>
</div>

<div id="leave-modal" class="modal">
    <div class="modal-box">
        <h3>üö® Oyundan √áƒ±k?</h3>
        <p>Oyundan ayrƒ±lmak istediƒüine emin misin?</p>
        <br>
        <div style="display:flex; gap:10px; width:100%; justify-content:center;">
            <button class="game-btn btn-red" onclick="confirmLeaveGame()">Evet, √áƒ±k</button>
            <button class="game-btn btn-blue" onclick="document.getElementById('leave-modal').style.display='none'">ƒ∞ptal</button>
        </div>
    </div>
</div>

<div class="main-wrapper" id="main-game-wrapper" style="display:none;">
    <div id="brand-area">
        <div class="brand-title">üçΩÔ∏è Son Tabak <span class="version">v0.9 (Open Beta)</span></div>
        <div class="brand-sub">üî•Kalority</div>
    </div>
    <div class="game-container">
        <div id="arrow-left" class="arrow-icon">‚¨ÜÔ∏è</div>
        <div id="arrow-right" class="arrow-icon">‚¨áÔ∏è</div>
        <div id="top-area">
            <div class="bot-wrapper" id="bot1-wrapper">
                <div class="bot-name" id="bot1-name">Oyuncu 2</div>
                <div class="bot-stack-visual" id="bot1-stack"></div>
                <div class="chat-bubble" id="bot1-chat"></div>
            </div>
            <div id="arrow-top-1" class="arrow-top-static">‚û°Ô∏è</div>
            <div class="bot-wrapper" id="bot2-wrapper">
                <div class="bot-name" id="bot2-name">Oyuncu 3</div>
                <div class="bot-stack-visual" id="bot2-stack"></div>
                <div class="chat-bubble" id="bot2-chat"></div>
            </div>
            <div id="arrow-top-2" class="arrow-top-static">‚û°Ô∏è</div>
            <div class="bot-wrapper" id="bot3-wrapper">
                <div class="bot-name" id="bot3-name">Oyuncu 4</div>
                <div class="bot-stack-visual" id="bot3-stack"></div>
                <div class="chat-bubble" id="bot3-chat"></div>
            </div>
        </div>
        <div id="play-area">
            <div id="draw-pile" class="card card-back-style" onclick="playerDrawCard()">
                <div id="penalty-badge">+0</div> 
                <div id="deck-count" style="position:absolute; bottom:10px; color:white; font-size:1.5em; text-shadow:1px 1px 2px #000;">0</div>
            </div>
            <div id="discard-pile"></div>
            <div id="son-tabak-popup">SON TABAK!<span id="son-tabak-who" class="popup-sub"></span></div>
            <div id="challenge-popup"><span id="challenge-who"></span><span id="challenge-result" class="challenge-sub"></span></div>
        </div>
        <div id="bottom-area">
            <div id="son-tabak-container">
                <button id="son-tabak-btn" onclick="playerSaySonTabak()">SON TABAK!</button>
                <button id="challenge-btn" onclick="challengePreviousPlayer()" disabled>‚úã ƒ∞Tƒ∞RAZ ET!</button>
            </div>
            <div id="player-hand" class="hand-normal"></div>
        </div>
    </div>
    <div class="right-panel">
        <div class="info-container">
            <div class="panel-header"><span>üèÜ Puan</span></div>
            <table id="score-table"><tbody></tbody></table>
        </div>
        <div class="chat-container">
            <div id="chat-messages"></div>
            <div class="chat-input-area">
                <input type="text" id="player-input" placeholder="Yaz..." onkeypress="handleChatKey(event)">
                <button id="send-btn" onclick="playerSendMessage()">‚û§</button>
            </div>
        </div>
    </div>
    <div class="buttons-container">
        <button class="game-btn btn-dark" onclick="openRules()">üìñ Kurallar</button>
        <button class="game-btn btn-blue" onclick="openPatternModal()">üé® Desen</button>
        <button class="game-btn btn-red" onclick="leaveGame()">‚ùå √áƒ±kƒ±≈ü</button>
    </div>
</div>

<div id="rules-modal" class="modal">
    <div class="modal-box" style="text-align:left; max-height:85vh; overflow-y:auto; font-family: 'Patrick Hand', cursive; padding: 20px; display: block;">
        
        <h3 style="text-align:center; color:#e67e22; font-size: 2em; margin-top: 0;">üìñ Mutfak Kurallarƒ±</h3>
        
        <h4 style="color:#d35400;">ü•ó Temel Ama√ß</h4>
        <p>Elindeki tabaklarƒ± rakiplerinden √∂nce bitir! Son karta geldiƒüinde <b>"SON TABAK"</b> diye baƒüƒ±rmayƒ± unutma.</p>

        <h4 style="color:#2980b9;">üéÆ Nasƒ±l Oynanƒ±r?</h4>
        <ul style="font-size:0.9em; padding-left:20px;">
            <li><b>Sebze veya Sayƒ±:</b> Ortadaki kartƒ±n sebzesi veya sayƒ±sƒ±yla aynƒ± olan bir kart atabilirsin. Yoksa desteden kart √ßekersin.</li>
            <li><b>Zorunlu Hamle:</b> Elinde oynanabilir bir <b>Sebze Kartƒ± (0-9)</b> varsa, onu oynamak zorundasƒ±n! Saklayƒ±p yerden kart √ßekemezsin (Etik deƒüil).</li>
            <li><b>Saklama:</b> Elinde √∂zellikli kartlar varsa, bunlarƒ± oynamayƒ±p yerden kart √ßekebilirsin.</li>
            <li><b>Pas Ge√ßme:</b> Kart √ßektikten sonra elinde uygun sebze kartƒ± yoksa veya √∂zel kartlarƒ±nƒ± saklamak istiyorsan desteye tekrar basarak pas ge√ßebilirsin.</li>
        </ul>

        <h4 style="color:#c0392b;">üî• √ñzellikli Kartlar</h4>
                <ul style="font-size:0.9em; padding-left:20px;">
            <li><b>‚ôªÔ∏è Geri d√∂n√º≈ü√ºm:</b> Oyunun y√∂n√ºn√º deƒüi≈ütirir.</li>
            <li><b>üî™ Bƒ±√ßak:</b> Bir sonrasƒ± oyuncunun sƒ±rasƒ±nƒ± ge√ßer.</li>
            <li><b>üì¶ +1:</b> Sonraki oyuncuya 1 kart √ßektirir. Kart cezasƒ± k√ºm√ºlatif olarak birikir.</li>
            <li><b>üì¶üì¶ +2:</b> Sonraki oyuncuya 2 kart √ßektirir. Kart cezasƒ± k√ºm√ºlatif olarak birikir.</li>
            <li><b>üç± Meze:</b> Bir √∂nceki oyuncuya ve bir sonraki oyuncuya 1 kart √ßektirir. Kart cezasƒ± k√ºm√ºlatif olarak birikir.</li>
            <li><b>üçΩÔ∏è Sofra:</b> Herkesin elindeki kartlar karƒ±≈ütƒ±rƒ±p eski sayƒ±sƒ±nda geri verir.</li>
            <li><b>üå™Ô∏è Mikser:</b> Oyuncularƒ±n ellerin istenilen y√∂nde (Saat y√∂n√º veya Tersi) deƒüi≈ütirir.</li>
            <li><b>üç≤ D√ºd√ºkl√º Tencere:</b> Herkese 1 kart√ßektirir. <b>ATAN DAHƒ∞L</b>.</li>
            <li><b>üçÖü•¶ü•îüçÜ G√ºve√ß:</b> Rengi (Sebzeyi) deƒüi≈ütirir.</li>
            <li><b>üßª Tuvalet Kaƒüƒ±dƒ±:</b> Kart √ßektirme cezasƒ±nƒ± <b>siler</b>.</li>
        </ul>
         <p style="font-size:0.9em;">Son kartƒ±nƒ±zƒ± attƒ±ƒüƒ±nƒ±zda eƒüer o kartƒ±n bir √∂zelliƒüi varsa, √∂nce √∂zellik uygulanƒ±r, <b>SONRA</b> oyun biter ve puanlar hesaplanƒ±r!</p>

        <h4 style="color:#f1c40f;">üö® SON TABAK ve ƒ∞Tƒ∞RAZ</h4>
        <ul style="font-size:0.9em; padding-left:20px;">
            <li><b>Son Tabak:</b> Elinde 2 kart varken birini atƒ±p TEK KART kalacaksan, <b>kartƒ± atmadan √∂nce</b> "SON TABAK" diye baƒüƒ±rmalƒ±sƒ±n.</li>
            <li><b>Unutursan:</b> Sen "Son Tabak" demeden tur diƒüer oyuncuya ge√ßerse, biri sana <b>"‚úã ƒ∞Tƒ∞RAZ ET"</b> butonuyla itiraz edebilir. Yakalanƒ±rsan ceza kartƒ± yersin!</li>
        </ul>

        <br>
        <div style="text-align:center; padding-bottom: 20px;">
            <button class="game-btn btn-blue" onclick="document.getElementById('rules-modal').style.display='none'">Anladƒ±m ≈ûef! üë®‚Äçüç≥</button>
        </div>
    </div>
</div>

<div id="pattern-modal" class="modal">
    <div class="modal-box">
        <h3>Kart Deseni</h3>
        <div class="pattern-grid" id="pattern-grid"></div>
        <br><button class="game-btn btn-blue" onclick="closePatternModal()">Kapat</button>
    </div>
</div>

<div id="color-modal" class="modal">
    <div class="modal-box">
        <h3>Renk Se√ß</h3>
        <div class="color-picker">
            <div class="color-opt bg-red" onclick="resolveColor('red')"></div>
            <div class="color-opt bg-green" onclick="resolveColor('green')"></div>
            <div class="color-opt bg-yellow" onclick="resolveColor('yellow')"></div>
            <div class="color-opt bg-purple" onclick="resolveColor('purple')"></div>
        </div>
    </div>
</div>

<div id="dir-modal" class="modal">
    <div class="modal-box">
        <h3>Y√∂n Se√ß (Mikser)</h3>
        <p id="dir-text" style="font-size:0.8em; margin:5px 0;">Eller hangi y√∂ne kaysƒ±n?</p>
        <div id="mixer-info"></div>
        <div class="color-picker">
            <button class="game-btn btn-blue" onclick="resolveDirection(1)">‚û°Ô∏è Saat</button>
            <button class="game-btn btn-blue" onclick="resolveDirection(-1)">‚¨ÖÔ∏è Ters</button>
        </div>
    </div>
</div>

<div id="end-modal" class="modal">
    <div class="modal-box" style="max-width: 400px;">
        <h2 id="winner-text"></h2>
        <div id="ai-summary" style="font-style:italic; font-size:0.9em; margin:15px 0; color:#555; border-top:1px solid #eee; border-bottom:1px solid #eee; padding:10px;"></div>
        <div id="final-scores"></div>
        <br>
        <div style="display:flex; gap:15px; width:100%;">
            <button id="end-continue-btn" class="game-btn btn-blue" style="flex:1;" onclick="toggleReadyState()">Devam Et ‚è≥</button>
            <button id="host-start-btn" class="game-btn btn-green" style="flex:1; display:none;" onclick="nextRound()">YENƒ∞ EL BA≈ûLAT</button>
            <button class="game-btn btn-red" style="flex:1;" onclick="leaveGame()">√áƒ±kƒ±≈ü</button>
        </div>
    </div>
</div>

<div id="toast" style="position:fixed; top:20px; left:50%; transform:translateX(-50%); background:#333; color:#fff; padding:10px 20px; border-radius:20px; display:none; z-index:5000;"></div>

<script>
/* --- OPTIMIZATION HELPERS: SERIALIZATION --- */
const serializeCard = (c) => {
    if(!c) return null;
    let cc = 'w'; // Default wild
    if(c.color === 'red') cc = 'r';
    else if(c.color === 'green') cc = 'g';
    else if(c.color === 'yellow') cc = 'y';
    else if(c.color === 'purple') cc = 'p';
    
    // Format: colorCode:val:chosenColor(optional)
    let str = `${cc}:${c.val}`;
    
    // Add chosenColor only if it exists and is not 'wild'
    if(c.chosenColor && c.chosenColor !== 'wild') {
        let chosen = 'r';
        if(c.chosenColor === 'green') chosen = 'g';
        if(c.chosenColor === 'yellow') chosen = 'y';
        if(c.chosenColor === 'purple') chosen = 'p';
        str += `:${chosen}`;
    }
    return str;
};

const deserializeCard = (s) => {
    if(!s || typeof s !== 'string') return s; // If already object or null
    const parts = s.split(':');
    const cc = parts[0];
    const val = parts[1];
    
    let color = 'wild';
    if(cc === 'r') color = 'red';
    else if(cc === 'g') color = 'green';
    else if(cc === 'y') color = 'yellow';
    else if(cc === 'p') color = 'purple';
    
    let type = 'num';
    if(isNaN(val) || val.indexOf('+') > -1) {
        if(color === 'wild') type = 'wild';
        else type = 'action';
    }
    
    let card = { color, val, type, name: val };
    
    // Handle chosenColor if exists
    if(parts.length > 2) {
        let chosenCode = parts[2];
        if(chosenCode === 'r') card.chosenColor = 'red';
        else if(chosenCode === 'g') card.chosenColor = 'green';
        else if(chosenCode === 'y') card.chosenColor = 'yellow';
        else if(chosenCode === 'p') card.chosenColor = 'purple';
    }
    
    return card;
};

/* --- MOBILE UI LOGIC --- */
function toggleLobbyTab(element) {
    if (window.innerWidth > 900) return; 
    const parent = element.parentElement;
    const allCols = document.querySelectorAll('.lobby-col');
    if (parent.classList.contains('open-tab')) {
        parent.classList.remove('open-tab');
    } else {
        allCols.forEach(col => col.classList.remove('open-tab'));
        allCols.forEach(col => col.querySelector('.col-content').style.opacity = '0');
        parent.classList.add('open-tab');
        setTimeout(() => parent.querySelector('.col-content').style.opacity = '1', 50);
    }
}

/* --- ANIMATION & CONFIG CONSTANTS --- */
const ANIM_CONFIG = {
    FLY_DURATION: 1000,           
    FLY_BUFFER: 1100,            
    DRAW_INTERVAL: 600,           
    INITIAL_DEAL: 250,           
    TOAST: 2000,                  
    POPUP: 3000,                  
    BOT_THINK: 300,                 
    HEARTBEAT_MS: 30000,           
    BOT_WATCHDOG: 3000           
};

/* --- CARD NAMES MAPPING --- */
const CARD_NAMES = {
    '+1': 'üì¶ +1',
    '+2': 'üì¶üì¶ +2',
    'Reverse': '‚ôªÔ∏è Geri D√∂n√º≈ü√ºm',
    'Block': 'üî™ Bƒ±√ßak',
    'Wild': 'G√ºve√ß',
    'Wild Anti-Draw': 'üßª Tuvalet Kaƒüƒ±dƒ±',
    'Wild Pot': 'üç≤ D√ºd√ºkl√º Tencere',
    'Wild Table': 'üçΩÔ∏è Sofra',
    'Wild Mixer': 'üå™Ô∏è Mikser',
    'Wild Meze': 'üç± Meze'
};

/* --- PATTERNS --- */
const CARD_PATTERNS = [
    'linear-gradient(135deg, #e67e22 0%, #d35400 100%)', // Default Orange
    'repeating-linear-gradient(45deg, #e67e22, #e67e22 10px, #d35400 10px, #d35400 20px)',
    'radial-gradient(circle, #e67e22 20%, #d35400 90%)',
    'conic-gradient(#e67e22, #d35400, #e67e22)',
    'linear-gradient(135deg, #2c3e50 0%, #000000 100%)', // Dark 1
    'repeating-linear-gradient(45deg, #2c3e50, #2c3e50 10px, #000000 10px, #000000 20px)',
    'radial-gradient(circle, #7f8c8d 20%, #2c3e50 90%)',
    'conic-gradient(#34495e, #000000, #34495e)'
];
let currentPattern = CARD_PATTERNS[0];

/* --- FIREBASE INIT --- */
const firebaseConfig = {
  apiKey: "AIzaSyDqyHqluehXJHt4xeanl51LRVG4AeQ3Ijk",
  authDomain: "son-tabak.firebaseapp.com",
  databaseURL: "https://son-tabak-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "son-tabak",
  storageBucket: "son-tabak.firebasestorage.app",
  messagingSenderId: "994436192152",
  appId: "1:994436192152:web:35d17d0dbb1d5d0015fded"
};

let app, db, auth;
try {
    app = firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    auth = firebase.auth();
    console.log("Firebase Init OK");
} catch(e) {
    alert("Firebase Hatasƒ±: " + e.message);
}

/* --- SES --- */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

const SoundFX = {
    playTone: (freq, type, duration, rampTo = 0.001) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(rampTo, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    },
    playCardSnap: () => SoundFX.playTone(800, 'sine', 0.1),
    playDraw: () => SoundFX.playTone(400, 'triangle', 0.15),
    playBlock: () => { SoundFX.playTone(1500, 'sawtooth', 0.1); setTimeout(() => SoundFX.playTone(2000, 'sine', 0.3), 50); },
    playReverse: () => { if(audioCtx.state === 'suspended') audioCtx.resume(); const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.3); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.3); },
    playWild: () => { [300, 400, 500, 600, 800].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'sine', 0.2), i*50)); },
    playBad: () => { SoundFX.playTone(150, 'sawtooth', 0.2); setTimeout(() => SoundFX.playTone(120, 'sawtooth', 0.4), 100); },
    playError: () => { SoundFX.playTone(100, 'square', 0.2); },
    playFanfare: () => { [523, 659, 783, 1046].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'square', 0.4), i * 150)); },
    playUno: () => SoundFX.playTone(1200, 'sine', 0.5)
};

let myUid = null; let myName = ""; let currentRoomId = null; let isHost = false;
let roomUnsubscribe = null; let myPlayerIdx = -1;
let localPlayers = []; let lastGameState = null; let lastChatTs = 0; let amIReady = false; let heartbeatInterval = null;
let actionQueue = []; let isProcessingQueue = false;
let localSaidSonTabak = false; 
let isDealing = false;
let previousPlayersList = [];
let myLobbyColor = '#333'; // Random color for lobby chat
let botInterval = null; // Botlarƒ± s√ºrekli kontrol edecek zamanlayƒ±cƒ±

/* --- LOGIC --- */
auth.onAuthStateChanged((user) => { if (user) myUid = user.uid; });

// GENERATE RANDOM HEX COLOR FOR LOBBY
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

// --- YENƒ∞ Sƒ∞LME FONKSƒ∞YONU: Alt koleksiyonlarƒ± da temizler ---
async function deleteFullRoom(roomId) {
    if (!roomId) return;
    const roomRef = db.collection("rooms").doc(roomId);
    
    // Firestore'da batch (toplu i≈ülem)
    const batch = db.batch();

    try {
        // 1. Mesajlarƒ± Bul ve Silme Listesine Ekle
        const msgsSnap = await roomRef.collection("messages").get();
        msgsSnap.forEach(doc => {
            batch.delete(doc.ref);
        });

        // 2. Presence (Online Durumu) Verilerini Bul ve Silme Listesine Ekle
        const presenceSnap = await roomRef.collection("presence").get();
        presenceSnap.forEach(doc => {
            batch.delete(doc.ref);
        });

        // 3. Ana Odayƒ± Silme Listesine Ekle
        batch.delete(roomRef);

        // 4. Hepsini Tek Seferde Uygula
        await batch.commit();
        console.log(`üßπ Oda (${roomId}) ve t√ºm i√ßerikleri tamamen silindi.`);
    } catch (error) {
        console.error("Oda silinirken hata:", error);
    }
}

// --- UPDATED JANITOR CLEANUP ---
async function performJanitorCleanup() {
    const TEN_MIN_MS = 10 * 60 * 1000;
    const cutoff = Date.now() - TEN_MIN_MS;
    
    // Sadece odalarƒ± temizleyelim, oyuncularƒ± ayrƒ± temizleriz.
    try {
        const snap = await db.collection("rooms")
            .where("lastActive", "<", cutoff)
            .limit(5) 
            .get();

        if (snap.empty) return;

        // Her bulunan eski oda i√ßin tam temizlik fonksiyonunu √ßaƒüƒ±r
        const deletePromises = snap.docs.map(doc => deleteFullRoom(doc.id));
        
        await Promise.all(deletePromises);
        console.log(`üßπ Temizlik√ßi: ${snap.size} adet eski oda ve i√ßerikleri temizlendi.`);

        // Global Players temizliƒüi (Batch ile basit√ße yapƒ±labilir √ß√ºnk√º alt koleksiyonu yok)
        const batch = db.batch();
        let opsCount = 0;
        const pSnap = await db.collection("global_players").where("lastSeen", "<", cutoff).get();
        pSnap.forEach(pDoc => {
            batch.delete(pDoc.ref);
            opsCount++;
        });
        if (opsCount > 0) await batch.commit();

    } catch (err) {
        console.log("Janitor Error:", err);
    }
}

document.getElementById('login-btn').addEventListener('click', () => {
    const name = document.getElementById('username-in').value.trim();
    if(!name) return alert("L√ºtfen bir isim gir!");
    document.getElementById('login-btn').innerText = "Giri≈ü Yapƒ±lƒ±yor...";
    
    auth.signInAnonymously()
        .then(() => {
            myName = name;
            myLobbyColor = getRandomColor();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('login-overlay').style.display = 'none';
            document.getElementById('lobby-overlay').style.display = 'flex';
            
            initLobbyFeatures(); // START NEW FEATURES
            updateGlobalStatus('lobby'); // Set initial status
            listenRooms();
            
            // --- TRIGGER JANITOR ---
            performJanitorCleanup();
        })
        .catch((e) => {
            alert("Giri≈ü Hatasƒ±: " + e.message);
            document.getElementById('login-btn').innerText = "Mutfaƒüa Gir";
        });
});

/* --- LOBBY CHAT & PLAYER LIST LOGIC --- */
let lobbyChatUnsub = null;
let globalPlayersUnsub = null;

function initLobbyFeatures() {
    // 1. Start Global Heartbeat for Status (Using OPTIMIZED interval)
    setInterval(() => {
        if(myUid) {
            let status = 'lobby';
            if(currentRoomId) status = (document.getElementById('main-game-wrapper').style.display === 'grid' || document.getElementById('main-game-wrapper').style.display === 'flex') ? 'playing' : 'waiting';
            updateGlobalStatus(status);
        }
    }, ANIM_CONFIG.HEARTBEAT_MS); // 30 seconds

    // 2. Listen to Lobby Chat
    lobbyChatUnsub = db.collection("lobby_chat").orderBy("ts", "asc").limit(10).onSnapshot(snapshot => {
        const div = document.getElementById('lobby-chat-msgs');
        div.innerHTML = "";
        snapshot.forEach(doc => {
            const data = doc.data();
            const line = document.createElement('div');
            line.className = 'l-chat-line';
            line.innerHTML = `<span style="font-weight:bold; color:${data.color}">${data.sender}:</span> ${data.msg}`;
            div.appendChild(line);
        });
        div.scrollTop = div.scrollHeight;
    });

    // 3. Listen to Online Players
    globalPlayersUnsub = db.collection("global_players").onSnapshot(snapshot => {
        const listDiv = document.getElementById('online-player-list');
        listDiv.innerHTML = "";
        const now = Date.now();
        let activeCount = 0;

        snapshot.forEach(doc => {
            const data = doc.data();
            if(now - data.lastSeen < 300000) {
                activeCount++;
                let dotClass = 'p-dot-lobby';
                if(data.status === 'waiting') dotClass = 'p-dot-wait';
                if(data.status === 'playing') dotClass = 'p-dot-play';
                
                const item = document.createElement('div');
                item.className = 'p-list-item';
                let displayName = data.name;
                if(doc.id === myUid) displayName = `<b>${displayName}</b>`;
                
                item.innerHTML = `<div class="p-dot ${dotClass}"></div>${displayName}`;
                listDiv.appendChild(item);
            }
        });
        
        if(activeCount === 0) listDiv.innerHTML = '<div style="text-align:center; color:#999; padding:5px;">Kimse yok.</div>';
    });
}

let lastReportedStatus = null;
let lastReportedTime = 0;

function updateGlobalStatus(status) {
    if(!myUid) return;
    const now = Date.now();
    if (status !== lastReportedStatus || now - lastReportedTime > 300000) {
        lastReportedStatus = status;
        lastReportedTime = now;
        db.collection("global_players").doc(myUid).set({
            name: myName,
            status: status,
            lastSeen: now
        }, { merge: true });
    }
}

function sendLobbyMessage() {
    const input = document.getElementById('l-chat-input');
    const msg = input.value.trim();
    if(!msg) return;

    db.collection("lobby_chat").get().then(snap => {
        if(snap.size >= 10) {
            let oldestDoc = snap.docs[0];
            let minTs = oldestDoc.data().ts;
            snap.docs.forEach(d => { if(d.data().ts < minTs) { minTs = d.data().ts; oldestDoc = d; } });
            oldestDoc.ref.delete();
        }
        db.collection("lobby_chat").add({
            sender: myName,
            msg: msg,
            color: myLobbyColor,
            ts: Date.now()
        });
        input.value = "";
    });
}

function listenRooms() {
    const list = document.getElementById('room-list'); 
    const tenMinsAgo = Date.now() - 600000;
    
    db.collection("rooms")
      .where("lastActive", ">", tenMinsAgo)
      .orderBy("lastActive", "desc")
      .limit(20)
      .onSnapshot((snapshot) => {
        list.innerHTML = "";
        if(snapshot.empty) list.innerHTML = "<div style='text-align:center;color:#777; margin-top:20px;'>Oda yok. ƒ∞lk odayƒ± sen kur!</div>";
        const now = Date.now();
        snapshot.forEach(docSnap => {
            const r = docSnap.data();
            if (r.lastActive && now - r.lastActive > 600000) { return; } 
            
            let realHumans = r.players.filter(p => !p.isBot).length;
            let totalBots = r.players.filter(p => p.isBot).length;
            
            let dotClass = 'st-green';
            if (r.status === 'playing') {
                if (totalBots > 0) dotClass = 'st-yellow';
                else dotClass = 'st-red';
            }
            
            let joinText = "Katƒ±l";
            if (r.status === 'playing') {
                if (totalBots > 0) joinText = "Oyuna Gir üöÄ";
                else joinText = "Dolu üîí"; 
            }
            
            if (r.hasPassword) joinText = "üîí " + joinText;

            const div = document.createElement('div');
            div.className = 'lobby-room-item';
            div.innerHTML = `
                <div class="room-info">
                    <div class="room-status-dot ${dotClass}"></div>
                    <div class="room-name-txt">${r.name}</div>
                    <div class="room-count-pill">${realHumans}/4</div>
                </div>
            `;
            
            if (r.status !== 'playing' || totalBots > 0) {
                const joinBtn = document.createElement('button');
                joinBtn.className = 'room-action-btn'; 
                joinBtn.innerText = joinText;
                joinBtn.onclick = () => joinRoom(docSnap.id, r.hasPassword);
                div.appendChild(joinBtn);
            }
            list.appendChild(div);
        });
    }, (error) => {
        console.log("Lobby Error (Probably need index):", error);
        list.innerHTML = "<div style='text-align:center;color:red;font-size:0.8em;'>Sorgu hatasƒ±. Veritabanƒ± ƒ∞ndexi eksik olabilir.</div>";
    });
}

document.getElementById('create-room-btn').addEventListener('click', () => {
    // SINGLE PLAYER REDIRECT
    if(document.getElementById('offline-mode-check').checked) {
        window.location.href = 'singleplayer.html';
        return;
    }

    const rName = document.getElementById('room-name-in').value.trim() || `${myName}'in Odasƒ±`;
    const rPass = document.getElementById('room-pass-in').value.trim();
    // OPTIMIZED: create room with serialized empty hands
    db.collection("rooms").add({
        name: rName, password: rPass, hasPassword: !!rPass, hostId: myUid, status: 'waiting', lastActive: Date.now(),
        players: [{ uid: myUid, name: myName, isBot: false, score: 0, hand: [], isReady: false, saidSonTabak: false, challengeUsed: false, lastSeen: Date.now() }],
        gameState: null
    }).then(ref => {
        currentRoomId = ref.id; isHost = true; enterWaitingRoom();
    });
});

function joinRoom(roomId, hasPass) {
    if(hasPass) {
        const p = prompt("Oda ≈ûifresi:"); if(p === null) return;
        db.collection("rooms").doc(roomId).get().then(doc => {
             if(doc.data().password !== p) return alert("Yanlƒ±≈ü ≈ûifre!");
             proceedJoin(roomId);
        });
    } else proceedJoin(roomId);
}

function proceedJoin(roomId) {
    const roomRef = db.collection("rooms").doc(roomId);
    roomRef.get().then(doc => {
        if(!doc.exists) return alert("Oda yok!");
        const rData = doc.data();
        let players = rData.players;
        
        let targetIndex = -1;
        
        // 1. Try to find a bot with my exact name (Rejoining logic)
        const sameNameBotIdx = players.findIndex(p => p.isBot && p.name.includes(myName));
        if (sameNameBotIdx !== -1) {
            targetIndex = sameNameBotIdx;
        } else {
            // 2. Otherwise find ANY bot
            const botIdx = players.findIndex(p => p.isBot);
            if (botIdx !== -1) targetIndex = botIdx;
        }

        if (targetIndex !== -1) {
            // Replacing a bot or rejoining
            players[targetIndex] = {
                ...players[targetIndex],
                uid: myUid,
                name: myName, // Reset name to player name (remove ü§ñ prefix)
                isBot: false,
                isReady: rData.status === 'playing', // Auto ready if joining mid-game
                isReady: true,
                lastSeen: Date.now()
            };
            roomRef.update({ players: players }).then(() => {
                currentRoomId = roomId; isHost = false; enterWaitingRoom();
            });
        } else {
            // Normal join (waiting room not full)
            if(rData.status === 'playing') return alert("Oda dolu ve bot yok!");
            if(players.length >= 4) return alert("Oda tamamen dolu!");
            
            roomRef.update({
                players: firebase.firestore.FieldValue.arrayUnion({ uid: myUid, name: myName, isBot: false, score: 0, hand: [], isReady: false, saidSonTabak: false, challengeUsed: false, lastSeen: Date.now() })
            }).then(() => {
                currentRoomId = roomId; isHost = false; enterWaitingRoom();
            });
        }
    });
}

// OPTIMIZED: CHAT LISTENER FUNCTION
let gameChatUnsub = null;
function initGameChat(roomId) {
    if(gameChatUnsub) gameChatUnsub();
    const chatDiv = document.getElementById('chat-messages');
    chatDiv.innerHTML = "";
    
    // LIMIT CHANGE: 30 -> 10
    gameChatUnsub = db.collection("rooms").doc(roomId).collection("messages")
        .orderBy("ts", "asc")
        .limit(10)
        .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === "added") {
                    const data = change.doc.data();
                    if(data.isSystem) {
                        // NO LOGGING TO UI AS REQUESTED
                    }
                    else {
                        // Find color from gamePlayers if available
                        let senderIdx = gamePlayers.findIndex(p => p.name === data.sender);
                        let color = senderIdx !== -1 ? (playerColors[senderIdx] || '#333') : '#333';
                        addChatLog(data.sender, data.msg, color);
                        
                        // Bubble for bots
                        if(senderIdx !== -1 && senderIdx !== myPlayerIdx) {
                            let relIdx = (senderIdx - myPlayerIdx + 4) % 4; 
                            let b = document.getElementById(`bot${relIdx}-chat`);
                            if(b) { b.innerText = data.msg; b.classList.add('visible'); setTimeout(()=>b.classList.remove('visible'),3000); }
                        }
                    }
                }
            });
        });
}

function enterWaitingRoom() {
    updateGlobalStatus('waiting'); // Update Status to Yellow
    document.getElementById('lobby-overlay').style.display = 'none';
    document.getElementById('waiting-room-overlay').style.display = 'flex';
    document.getElementById('leave-room-btn').onclick = () => { document.getElementById('leave-modal').style.display = 'flex'; }; 

    if(roomUnsubscribe) roomUnsubscribe();
    
    if(heartbeatInterval) clearInterval(heartbeatInterval);
    heartbeatInterval = setInterval(sendHeartbeat, ANIM_CONFIG.HEARTBEAT_MS);

    // --- WATCHDOG SYSTEM ---
    if(botInterval) clearInterval(botInterval);
    botInterval = setInterval(runBotWatchdog, 1000); // Check bot every second

    // Initialize Chat Listener
    initGameChat(currentRoomId);

    roomUnsubscribe = db.collection("rooms").doc(currentRoomId).onSnapshot((docSnap) => {
        if(!docSnap.exists) { location.reload(); return; }
        const data = docSnap.data();
        localPlayers = data.players;

        // JOIN/LEAVE LOGIC - TOAST ONLY
        if(previousPlayersList.length > 0) {
            localPlayers.forEach(p => {
                if(!previousPlayersList.find(op => op.uid === p.uid)) {
                    if(!p.isBot) {
                        showToast(`${p.name} odaya katƒ±ldƒ±!`);
                    }
                }
            });
            previousPlayersList.forEach(op => {
                if(!localPlayers.find(p => p.uid === op.uid)) {
                        showToast(`${op.name} ayrƒ±ldƒ±.`);
                }
            });
        }
        previousPlayersList = localPlayers;
        
        const firstHuman = localPlayers.find(p => !p.isBot);
        isHost = (firstHuman && firstHuman.uid === myUid);

        document.getElementById(isHost ? 'wr-host-controls' : 'wr-guest-controls').style.display = 'block';
        document.getElementById(!isHost ? 'wr-host-controls' : 'wr-guest-controls').style.display = 'none';
        document.getElementById('wr-room-name').innerText = `Masa: ${data.name}`;
        
        // --- NEW LOUNGE CARD RENDER ---
        const grid = document.getElementById('wr-player-grid');
        grid.innerHTML = "";
        
        localPlayers.forEach(p => {
            const isMe = p.uid === myUid;
            const isHostPlayer = p.uid === firstHuman?.uid;
            // Generate deterministic color from name for avatar
            const colors = ['#e74c3c', '#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22'];
            const colorIdx = p.name.length % colors.length;
            const avatarColor = colors[colorIdx];
            const firstLetter = p.name.charAt(0).toUpperCase();

            const card = document.createElement('div');
            card.className = `wr-card ${isMe ? 'active' : ''} ${isHostPlayer ? 'host-card' : ''}`;
            card.innerHTML = `
                ${isHostPlayer ? '<div class="host-crown">üëë</div>' : ''}
                <div class="wr-status ready"></div>
                <div class="wr-avatar" style="background:${avatarColor}">${p.isBot ? 'ü§ñ' : firstLetter}</div>
                <div class="wr-name">${p.name}</div>
                <div class="wr-role">${isHostPlayer ? 'Masa Sahibi' : (p.isBot ? 'Bot' : 'Oyuncu')}</div>
            `;
            grid.appendChild(card);
        });

        if(data.status === 'playing') {
            document.getElementById('waiting-room-overlay').style.display = 'none';
            document.getElementById('main-game-wrapper').style.display = 'grid';
            updateGlobalStatus('playing'); // Update Status to Red
            myPlayerIdx = localPlayers.findIndex(p => p.uid === myUid);
            syncGameLoop(data);
        }
    });
}

function sendHeartbeat() {
    if(!currentRoomId || !myUid) return;
    // OPTIMIZATION: Do not update main room doc. Update subcollection to avoid triggering download.
    db.collection("rooms").doc(currentRoomId)
      .collection("presence").doc(myUid)
      .set({
          name: myName,
          lastSeen: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
}

document.getElementById('start-game-btn').addEventListener('click', () => {
    if(localPlayers.length < 2) return alert("En az 2 oyuncu!");
    let finalPlayers = [...localPlayers];
    const botNames = ["ü§ñ Rifu", "ü§ñ Utku", "ü§ñ K√ºbra"];
    let botIdx = 0;
    while(finalPlayers.length < 4) {
        finalPlayers.push({ uid: 'bot_' + Date.now() + '_' + botIdx, name: botNames[botIdx % botNames.length], isBot: true, score: 0, hand: [], isReady: true, saidSonTabak: false, challengeUsed: false, lastSeen: Date.now() });
        botIdx++;
    }
    finalPlayers = shuffleDeck(finalPlayers);
    finalPlayers = finalPlayers.map(p => ({...p, isReady: false, saidSonTabak: false, challengeUsed: false }));
    
    const newDeck = createFullDeck();
    const hands = [[], [], [], []];
    for(let i=0; i<7; i++) { for(let p=0; p<4; p++) hands[p].push(newDeck.pop()); }
    finalPlayers.forEach((p, i) => p.hand = hands[i].map(serializeCard)); // OPTIMIZED: Serialize initial hands
    
    let first = newDeck.pop();
    while(first.color === 'wild' || first.type === 'action') { newDeck.unshift(first); first = newDeck.pop(); }
    
    // OPTIMIZED: Serialize Deck and Discard Pile
    const initialState = {
        deck: newDeck.map(serializeCard), 
        discardPile: [serializeCard(first)], 
        currentPlayer: Math.floor(Math.random()*4), direction: 1, drawStack: 0, gameActive: true,
        lastAction: { type: 'start', timestamp: Date.now() }, vulnerablePlayerIdx: -1, playerColors: shuffleDeck(['#c0392b', '#f1c40f', '#8e44ad', '#27ae60']),
        hasDrawn: false
    };
    db.collection("rooms").doc(currentRoomId).update({ status: 'playing', players: finalPlayers, gameState: initialState, lastActive: Date.now() });
});

/* --- GAME LOOP (Sync Logic) --- */
let isBotThinking = false; 
let lastBotActionTime = 0; 

function syncGameLoop(roomData) {
    const gs = roomData.gameState;
    
    // --- 10 MINUTE AUTO-DELETE CHECK (HOST ONLY) ---
    if(isHost && roomData.lastActive && (Date.now() - roomData.lastActive > 600000)) {
        console.log("Room inactive for 10 mins. Closing...");
        confirmLeaveGame(); // This will trigger delete as host leaves
        return;
    }

    if(!gs) return;
    
    // OPTIMIZED: DESERIALIZE DATA
    gameDeck = (gs.deck || []).map(deserializeCard);
    gameDiscard = (gs.discardPile || []).map(deserializeCard);
    
    // Players are objects, hands are strings
    gamePlayers = roomData.players;
    gameHands = gamePlayers.map(p => (p.hand || []).map(deserializeCard));
    
    currentPlayer = gs.currentPlayer; direction = gs.direction; drawStack = gs.drawStack;
    gameActive = gs.gameActive; vulnerablePlayerIdx = gs.vulnerablePlayerIdx; playerColors = gs.playerColors;
    hasDrawn = gs.hasDrawn || false;

    if(currentPlayer !== myPlayerIdx) localSaidSonTabak = false;

    if(lastGameState && lastGameState.lastAction.timestamp !== gs.lastAction.timestamp) {
        // Deserialize card in action if present
        let action = gs.lastAction;
        if(action.card && typeof action.card === 'string') {
            action.card = deserializeCard(action.card);
        }
        actionQueue.push(action);
        processActionQueue();
    } else if (!isProcessingQueue) {
        updateUI(); 
    }
    
    // GAME END CHECK (Wait for Queue)
    if (gs.winnerIdx !== undefined && gs.winnerIdx !== -1 && gameActive === false) {
        if(actionQueue.length === 0 && !isProcessingQueue) { // Wait for animation
             if(document.getElementById('end-modal').style.display !== 'flex') showEndGame(gs.winnerIdx, roomData.players);
             updateReadyStatusUI();
        }
    }
    
    if(!lastGameState && gs.lastAction.type === 'start') {
          actionQueue.push(gs.lastAction); 
          processActionQueue();
    }
    
    lastGameState = gs;

    // Trigger Bot Check (Extracted Function)
    attemptBotMove();
}

function attemptBotMove() {
    if(isHost && gameActive && !isProcessingQueue && actionQueue.length === 0 && !isBotThinking) {
        const currentPObj = gamePlayers[currentPlayer];
        if(currentPObj && currentPObj.isBot) {
            isBotThinking = true;
            lastBotActionTime = Date.now(); 
            setTimeout(() => {
                hostBotTurn().then(() => { isBotThinking = false; }).catch(e => { console.error("Bot Error", e); isBotThinking = false; });
            }, ANIM_CONFIG.BOT_THINK);
        }
    }
}

function runBotWatchdog() {
    if(!isHost || !gameActive || !currentRoomId) return;
    if(isProcessingQueue && actionQueue.length > 0) return;
    const currentPObj = gamePlayers[currentPlayer];
    if(currentPObj && currentPObj.isBot) {
        // If stuck thinking for too long
        if(isBotThinking && (Date.now() - lastBotActionTime > ANIM_CONFIG.BOT_WATCHDOG)) {
            console.warn("üö® Bot Watchdog: Bot takƒ±ldƒ±, zorla oynatƒ±lƒ±yor...");
            isBotThinking = false;
            attemptBotMove();
        }
        // If turn is bot's but not thinking (Deadlock)
        else if (!isBotThinking && !isProcessingQueue) {
            attemptBotMove();
        }
    }
}

/* --- ACTION HANDLING --- */
async function processActionQueue() {
    if(isProcessingQueue) return;
    
    if(actionQueue.length === 0) {
        // QUEUE EMPTY - CHECK WINNER
        // FIX: Explicitly check for winner when queue is drained
        if (lastGameState && lastGameState.winnerIdx !== undefined && lastGameState.winnerIdx !== -1 && lastGameState.gameActive === false) {
             if(document.getElementById('end-modal').style.display !== 'flex') {
                 showEndGame(lastGameState.winnerIdx, gamePlayers);
                 updateReadyStatusUI();
             }
        }
        return;
    }
    
    isProcessingQueue = true;
    const action = actionQueue.shift();
    await handleRemoteAction(action); 
    updateUI();
    isProcessingQueue = false;
    
    // FIX: Trigger Bot Move immediately after animation ends if it's bot's turn
    attemptBotMove();
    
    processActionQueue();
}

async function handleRemoteAction(action) {
    if(!action) return;
    
    if(action.type === 'sonTabak') {
        const pName = gamePlayers[action.pIdx].name;
        showSonTabakPopup(pName);
        SoundFX.playUno();
    }
    else if(action.type === 'challenge') {
        let victimName = action.victimIdx !== undefined ? gamePlayers[action.victimIdx].name : "Biri";
        let msg = action.success ? "BA≈ûARILI! ‚úÖ" : "BA≈ûARISIZ! ‚ùå";
        let detail = action.success ? `${victimName} ceza yedi!` : `ƒ∞tiraz haksƒ±zdƒ±!`;
        showChallengePopup(action.success, msg, detail);
        
        if(action.success) SoundFX.playFanfare(); else SoundFX.playBad();
        
        if(action.victimIdx !== undefined) {
            await wait(500); 
            let targetId = action.victimIdx === myPlayerIdx ? 'player-hand' : `bot${(action.victimIdx - myPlayerIdx + 4) % 4}-wrapper`;
            animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null);
        }
    }
    else if(action.type === 'newRound' || action.type === 'start') {
        document.getElementById('end-modal').style.display = 'none';
        amIReady = false; 
        document.getElementById('end-continue-btn').innerText = "Devam Et ‚è≥";
        document.getElementById('end-continue-btn').className = "game-btn btn-blue";
        await animateInitialDeal();
    }
    else if(action.type === 'play') {
        let pIdx = action.pIdx;
        let sourceId = pIdx === myPlayerIdx ? 'player-hand' : pIdx === (myPlayerIdx+1)%4 ? 'bot1-wrapper' : pIdx === (myPlayerIdx+2)%4 ? 'bot2-wrapper' : 'bot3-wrapper';
        let source = document.getElementById(sourceId);
        if(pIdx === myPlayerIdx && source.children.length > 0) source = source.children[Math.min(source.children.length-1, 3)];
        
        await new Promise(r => animateFly(source, document.getElementById('discard-pile'), createCardHTML(action.card), r));
        
        document.getElementById('discard-pile').innerHTML = createCardHTML(action.card);
        if(action.card.val === 'Block') { SoundFX.playBlock(); animateBlock(pIdx); }
        else if(action.card.val === 'Reverse') { SoundFX.playReverse(); await animateReverse(); } 
        else if(action.card.color === 'wild') SoundFX.playWild();
        else SoundFX.playCardSnap();

        if(action.card.val === 'Wild Table') await animateTableEffect();
        if(action.card.val === 'Wild Mixer') await animateMixerEffect(direction); 
        if(action.card.val === 'Wild Pot') animatePotEffect(pIdx, direction);
        if(action.card.val === 'Wild Meze') animateMezeEffect(pIdx);

        // --- NEW: END GAME PENALTY ANIMATION ---
        if(action.penaltyCount && action.penaltyCount > 0) {
            // Calculate who the victim is. The currentPlayer global is updated to the next person (victim)
            // relative to the action.
            let targetIdx = currentPlayer;
            let targetId = targetIdx === myPlayerIdx ? 'player-hand' : `bot${(targetIdx - myPlayerIdx + 4) % 4}-wrapper`;
            
            for(let i=0; i<action.penaltyCount; i++) {
                animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null);
                await wait(150); // Fast burst for effect
            }
            await wait(500); // Pause before end screen shows
        }
    } 
    else if(action.type === 'draw') {
        SoundFX.playDraw();
        let targetId = action.pIdx === myPlayerIdx ? 'player-hand' : `bot${(action.pIdx - myPlayerIdx + 4) % 4}-wrapper`;
        isDealing = true;
        let currentHandClone = [...gameHands[myPlayerIdx]]; 
        
        for(let k=0; k<action.count; k++) { 
             let cardToVisualize = null;
             if(action.pIdx === myPlayerIdx) {
                 let idx = currentHandClone.length - action.count + k;
                 if(idx >= 0 && idx < currentHandClone.length) cardToVisualize = createCardHTML(currentHandClone[idx]);
             }
             
             await new Promise(resolve => {
                 animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), cardToVisualize, () => {
                     if(action.pIdx === myPlayerIdx && cardToVisualize) {
                         let div = document.createElement('div'); div.innerHTML = cardToVisualize; 
                         let el = div.firstElementChild;
                         document.getElementById('player-hand').appendChild(el);
                     }
                     resolve();
                 });
             });
             await wait(100); 
        }
        isDealing = false;
        updateUI(); 
    }
    await wait(200);
}

/* --- GAME LOGIC (Host/Player) --- */
let gameDeck = [], gameDiscard = [], gameHands = [], gamePlayers = [], gameActive = false, direction = 1, currentPlayer = 0, drawStack = 0, vulnerablePlayerIdx = -1, playerColors = [], pendingWild = null, hasDrawn = false, lastWinner = -1;

function canPlay(card) {
    let top = gameDiscard[gameDiscard.length-1]; let topColor = top.chosenColor || top.color;
    if(drawStack > 0) { if(card.val === '+2' || card.val === 'Wild Meze' || card.val === 'Wild Anti-Draw') return true; if(card.val === '+1') { return top.val === '+2' || top.val === 'Wild Meze' ? card.color === topColor : true; } return false; }
    return card.color === 'wild' || card.color === topColor || card.val === top.val;
}

function playerDrawCard() {
    if(currentPlayer !== myPlayerIdx) return;
    
    // NEW RULE: Check if player has playable NUMBER cards
    const hand = gameHands[myPlayerIdx];
    const hasPlayableNum = hand.some(c => c.type === 'num' && canPlay(c));
    
    // If not in penalty mode (drawStack == 0) and has playable number, MUST play
    if(drawStack === 0 && hasPlayableNum) {
        showToast("Oynanabilir Sayƒ± Kartƒ±n var! Oynamak zorundasƒ±n.");
        return;
    }

    // IF already drawn, check logic for PASSING
    if(hasDrawn) { 
        // Logic for Passing Turn
        // Check the LAST drawn card (it's the last in hand array)
        if(hand.length > 0) {
            const lastCard = hand[hand.length - 1];
            // If the drawn card is a playable NUMBER card, player CANNOT pass
            if(lastCard.type === 'num' && canPlay(lastCard)) {
                showToast("√áektiƒüin Sayƒ± Kartƒ±nƒ± oynamak zorundasƒ±n!");
                return;
            }
        }
        serverPassTurn(myPlayerIdx); 
        return; 
    }
    
    // Logic for Drawing
    let count = drawStack > 0 ? drawStack : 1;
    let isPenalty = drawStack > 0;
    
    serverDrawCard(myPlayerIdx, count, isPenalty);
    if(isPenalty || count > 1) { 
        setTimeout(() => serverPassTurn(myPlayerIdx), 1500 + (count*600)); 
    }
}

function playerPlayCard(idx) {
    if(currentPlayer !== myPlayerIdx) return;
    let card = gameHands[myPlayerIdx][idx];
    if(canPlay(card)) {
        if(card.color === 'wild') {
            if(card.val === 'Wild Anti-Draw') { let top = gameDiscard[gameDiscard.length-1]; card.chosenColor = top.chosenColor || top.color; if(card.chosenColor==='wild') card.chosenColor = 'red'; serverPlayCard(myPlayerIdx, idx, card, 1, localSaidSonTabak); }
            else { pendingWild = { idx, card }; document.getElementById('color-modal').style.display = 'flex'; }
        } else serverPlayCard(myPlayerIdx, idx, card, 1, localSaidSonTabak);
    } else { SoundFX.playError(); showToast("Oynanamaz!"); }
}
function resolveColor(c) { 
    document.getElementById('color-modal').style.display = 'none'; 
    if(pendingWild) { 
        let card = pendingWild.card; card.chosenColor = c; 
        if(card.val === 'Wild Mixer') { 
            let pRightIdx = (myPlayerIdx + 1) % 4; 
            let pLeftIdx = (myPlayerIdx + 3) % 4; 
            let pRightName = gamePlayers[pRightIdx].name;
            let pLeftName = gamePlayers[pLeftIdx].name;
            let pRightCount = gameHands[pRightIdx].length;
            let pLeftCount = gameHands[pLeftIdx].length;

            document.getElementById('mixer-info').innerHTML = `
                <b>‚û°Ô∏è Saat:</b> ${pLeftName}'in elini (${pLeftCount} Kart) alacaksƒ±n.<br>
                <b>‚¨ÖÔ∏è Ters:</b> ${pRightName}'in elini (${pRightCount} Kart) alacaksƒ±n.
            `;
            document.getElementById('dir-modal').style.display = 'flex'; 
        } else { 
            serverPlayCard(myPlayerIdx, pendingWild.idx, card, 1, localSaidSonTabak); 
            pendingWild = null; 
        } 
    } 
}
function resolveDirection(d) { document.getElementById('dir-modal').style.display = 'none'; if(pendingWild) { serverPlayCard(myPlayerIdx, pendingWild.idx, pendingWild.card, d, localSaidSonTabak); pendingWild = null; } }

function playerSaySonTabak() { 
    if(currentPlayer !== myPlayerIdx || gameHands[myPlayerIdx].length > 2) return; 
    
    localSaidSonTabak = true; 
    
    let ps = [...gamePlayers]; ps[myPlayerIdx].saidSonTabak = true; 
    
    // Ps hands might be strings, keep them that way
    
    db.collection("rooms").doc(currentRoomId).update({ 
        players: ps, 
        "gameState.vulnerablePlayerIdx": -1, 
        "gameState.lastAction": { type: 'sonTabak', pIdx: myPlayerIdx, timestamp: Date.now() },
    }); 
    // NO SYSTEM LOG
}

function challengePreviousPlayer() {
    if(currentPlayer !== myPlayerIdx || gamePlayers[myPlayerIdx].challengeUsed) return;
    
    // --- PENALTY ESCAPE FIX: Cannot challenge if penalty stack is active ---
    if(drawStack > 0) {
        showToast("Cezalƒ± durumda itiraz edemezsin!");
        return;
    }
    
    if(vulnerablePlayerIdx !== -1) { 
        serverPunishVulnerable(vulnerablePlayerIdx); 
        // NO SYSTEM LOG
    }
    else { 
        serverPunishChallenger(myPlayerIdx); 
        // NO SYSTEM LOG
    }
}
function playerSendMessage() { 
    let input = document.getElementById('player-input'); 
    let msg = input.value.trim(); 
    if(msg) { 
        const messagesRef = db.collection("rooms").doc(currentRoomId).collection("messages");
        
        // LIMIT CHECK AND DELETE
        messagesRef.get().then(snap => {
            if(snap.size >= 10) {
                // Find oldest and delete it
                let oldest = snap.docs.sort((a,b) => a.data().ts - b.data().ts)[0];
                oldest.ref.delete();
            }
            // Add new message
            messagesRef.add({ sender: myName, msg: msg, ts: Date.now(), isSystem: false })
            .catch(err => console.error("Message send failed:", err)); 
        });

        db.collection("rooms").doc(currentRoomId).update({ "lastActive": Date.now() }); 
        input.value = ''; 
    } 
}

/* --- SERVER ACTIONS (OPTIMIZED) --- */
// Reshuffling Helper (Builds a new deck minus the cards in play)
function rebuildDeckFromState(currentHands, topDiscardCard) {
    let fullDeck = createFullDeck().map(serializeCard);
    
    // Gather all cards currently in players' hands to remove them
    let activeCards = [];
    currentHands.forEach(hand => {
        hand.forEach(c => activeCards.push(serializeCard(c)));
    });
    
    // Also remove the top card of the discard pile
    if(topDiscardCard) {
        activeCards.push(serializeCard(topDiscardCard));
    }
    
    // Filter the full deck
    activeCards.forEach(cardStr => {
        let idx = fullDeck.indexOf(cardStr);
        if(idx > -1) {
            fullDeck.splice(idx, 1);
        }
    });
    
    // Deserialize and Shuffle remaining
    return shuffleDeck(fullDeck.map(deserializeCard));
}

async function serverDrawCard(pIdx, count, isPenalty = false) {
    let newDeck = [...gameDeck], newDiscard = [...gameDiscard];
    let newHands = gameHands.map(h => [...h]); 
    
    // RESHUFFLE LOGIC
    if(newDeck.length < count) { 
        // Perform Smart Reshuffle
        let topCard = newDiscard.length > 0 ? newDiscard[newDiscard.length - 1] : null;
        newDeck = rebuildDeckFromState(newHands, topCard);
        
        // If still empty (extremely rare edge case where ALL cards are in hands), create full deck
        if(newDeck.length === 0) newDeck = createFullDeck();
    }

    for(let i=0; i<count; i++) if(newDeck.length > 0) newHands[pIdx].push(newDeck.pop());
    
    // Serialize for DB
    let pUpdates = [...gamePlayers]; 
    pUpdates[pIdx].hand = newHands[pIdx].map(serializeCard); 
    pUpdates[pIdx].saidSonTabak = false;
    
    let updates = { 
        "players": pUpdates, 
        "gameState.deck": newDeck.map(serializeCard), 
        "gameState.discardPile": newDiscard.map(serializeCard), 
        "gameState.drawStack": 0, 
        "gameState.hasDrawn": true, 
        "gameState.lastAction": { type: 'draw', pIdx, count, timestamp: Date.now(), isPenalty: isPenalty }, 
        "lastActive": Date.now()
    };
    if(isPenalty) {
        updates["gameState.hasDrawn"] = false; 
    }
    
    await db.collection("rooms").doc(currentRoomId).update(updates);
    
    // NO SYSTEM LOG
}
async function serverPassTurn(pIdx) { 
    await db.collection("rooms").doc(currentRoomId).update({ "gameState.currentPlayer": (currentPlayer + direction + 4) % 4, "gameState.hasDrawn": false, "gameState.vulnerablePlayerIdx": -1, "lastActive": Date.now() });
    // NO SYSTEM LOG
}

async function serverPlayCard(pIdx, cIdx, cardWithColor, mixerDir = 1, declaredSonTabak = false) {
    let newHands = gameHands.map(h => [...h]); 
    let newDiscard = [...gameDiscard];
    if(!newHands[pIdx] || !newHands[pIdx][cIdx]) return;

    let card = newHands[pIdx][cIdx]; if(cardWithColor) card = cardWithColor;
    
    newHands[pIdx].splice(cIdx, 1); 
    newDiscard.push(card);
    
    // --- OPTIMIZATION: Truncate Discard Pile ---
    if(newDiscard.length > 2) {
        newDiscard = newDiscard.slice(-2);
    }
    
    let newDir = direction, newDrawStack = drawStack, nextP = currentPlayer, newWinner = -1;
    let playerUpdates = [...gamePlayers]; playerUpdates[pIdx].saidSonTabak = false;
    
    // --- UPDATE DIRECTION & NEXT PLAYER CALCULATION ---
    if(card.val === 'Wild Mixer') { 
        newDir = mixerDir || 1; 
    } else if (card.val === 'Reverse') { 
        newDir *= -1; 
    }

    // Determine basic next player
    if(card.val === 'Block') nextP = (currentPlayer + (newDir * 2) + 4) % 4; 
    else nextP = (currentPlayer + newDir + 4) % 4; 

    // Determine Draw Stack
    if(card.val === '+1') newDrawStack += 1; 
    if(card.val === '+2') newDrawStack += 2; 
    if(card.val === 'Wild Meze') newDrawStack += 1; 
    if(card.val === 'Wild Anti-Draw') newDrawStack = 0;
    
    // --- SPECIAL END GAME RULES (Must execute effects first) ---

    // D√ºd√ºkl√º Tencere (Wild Pot) Rule: Cannot win.
    if(card.val === 'Wild Pot') {
        // Execute Pot Effect: Everyone draws 1
        for(let k=0; k<4; k++) {
            let targetP = (pIdx + (k * newDir) + 4) % 4; 
            if(gameDeck.length > 0) newHands[targetP].push(gameDeck.pop());
            // Safe reshuffle if needed would go here, using existing helpers if integrated better
        }
        
        // If this was the last card, force draw 1 additional card for player
        if(newHands[pIdx].length === 0) {
            if(gameDeck.length > 0) newHands[pIdx].push(gameDeck.pop());
            newWinner = -1; // No winner
        }
    }

    // Wild Table Rule (Sofra)
    else if(card.val === 'Wild Table') {
        let isWinning = (newHands[pIdx].length === 0);
        let playersToShuffle = [0,1,2,3];
        
        if(isWinning) {
            // Exclude winner from shuffle
            playersToShuffle = playersToShuffle.filter(i => i !== pIdx);
        }

        let counts = [];
        let allCards = [];
        
        playersToShuffle.forEach(i => {
            counts.push({idx: i, count: newHands[i].length});
            allCards.push(...newHands[i]);
            newHands[i] = []; // Empty hands
        });
        
        allCards = shuffleDeck(allCards);
        
        // Redistribute
        counts.forEach(c => {
            for(let j=0; j<c.count; j++) {
                if(allCards.length > 0) newHands[c.idx].push(allCards.pop());
            }
        });
        
        // If winning, newWinner will be set later by empty hand check
    }

    // Wild Mixer Rule
    else if(card.val === 'Wild Mixer') {
        let isWinning = (newHands[pIdx].length === 0);
        
        if(isWinning) {
            // Rotate only losers
            // Order depends on direction. 
            // Standard Mixer Logic:
            // If CW: P1 takes P0, P2 takes P1... NO.
            // Logic implemented: let temp = newHands[3]; ... newHands[0] = temp;
            // Let's implement rotation for remaining 3 players.
            
            let losers = [0,1,2,3].filter(i => i !== pIdx);
            // Sort losers to maintain cycle order (e.g. 0, 2, 3)
            // But we need to rotate relative to game direction.
            // Simple rotation: Map values to next loser in direction
            
            let currentHandsMap = {};
            losers.forEach(i => currentHandsMap[i] = [...newHands[i]]);
            
            for(let i=0; i<losers.length; i++) {
                let current = losers[i];
                // Find next loser in direction
                let nextIndex = (i + newDir + losers.length) % losers.length; 
                let sourceIndex = (i - newDir + losers.length) % losers.length;
                // If I am 'current', I take from 'sourceIndex' in standard shift?
                // Mixer code earlier:
                // if(newDir === 1) { let temp = newHands[3]; newHands[3] = newHands[2]; newHands[2] = newHands[1]; newHands[1] = newHands[0]; newHands[0] = temp; }
                // This shifts hands COUNTER to player index. (P0 gets P3's hand).
                // Let's stick to simple swap logic.
                
                // Effective rotation for 3 players:
                newHands[current] = currentHandsMap[losers[sourceIndex]];
            }
        } else {
            // Standard Mixer Logic (Everyone)
            if(newDir === 1) { let temp = newHands[3]; newHands[3] = newHands[2]; newHands[2] = newHands[1]; newHands[1] = newHands[0]; newHands[0] = temp; } 
            else { let temp = newHands[0]; newHands[0] = newHands[1]; newHands[1] = newHands[2]; newHands[2] = newHands[3]; newHands[3] = temp; } 
        }
    }
    
    // Wild Meze Logic
    else if(card.val === 'Wild Meze') {
        let prevP = (pIdx - newDir + 4) % 4; 
        if(gameDeck.length > 0) newHands[prevP].push(gameDeck.pop()); 
        // Logic already affects hands, so standard win check will see updated state
    }
    
    // --- FINAL WINNER CHECK & PENALTY ENFORCEMENT ---
    let finalPenaltyCount = 0; // Store this for animation

    if(newHands[pIdx].length === 0) {
        newWinner = pIdx;
        
        // Cumulative Penalty Check (+1, +2, Accumulated Stack)
        // If ending with penalty, NEXT player draws the stack
        if(newDrawStack > 0) {
             // Perform Smart Reshuffle if needed before drawing
            if(gameDeck.length < newDrawStack) { 
                gameDeck = rebuildDeckFromState(newHands, newDiscard[newDiscard.length-1]);
                if(gameDeck.length === 0) gameDeck = createFullDeck();
            }

            for(let k=0; k<newDrawStack; k++) {
                if(gameDeck.length > 0) newHands[nextP].push(gameDeck.pop());
            }
            finalPenaltyCount = newDrawStack; // Store actual count for animation
            newDrawStack = 0; // Penalty consumed
        }
    }

    // SERIALIZE HANDS
    playerUpdates = playerUpdates.map((p, i) => ({...p, hand: newHands[i].map(serializeCard)}));
    
    let isSafe = gamePlayers[pIdx].saidSonTabak || declaredSonTabak;

    // FIX: AUTO SAFE IF MIXER/TABLE SWAPPED TO 1 CARD
    if(newHands[pIdx].length === 1 && !isSafe) {
        if(card.val === 'Wild Mixer' || card.val === 'Wild Table') {
            isSafe = true;
            playerUpdates[pIdx].saidSonTabak = true; // Flag for next state
        }
    }

    let newVulnerable = (newHands[pIdx].length === 1 && !isSafe) ? pIdx : -1; 
    if(nextP === newVulnerable) newVulnerable = -1;
    
    let updates = { 
        "players": playerUpdates, 
        "gameState.discardPile": newDiscard.map(serializeCard), // SERIALIZE
        "gameState.currentPlayer": nextP, 
        "gameState.direction": newDir, 
        "gameState.drawStack": newDrawStack, 
        "gameState.vulnerablePlayerIdx": newVulnerable, 
        "gameState.hasDrawn": false, 
        "gameState.lastAction": { type: 'play', pIdx, card: serializeCard(card), timestamp: Date.now(), penaltyCount: finalPenaltyCount }, // SERIALIZE + ADD PENALTY
        "lastActive": Date.now()
    };
    if(card.val === 'Wild Pot' || card.val === 'Wild Meze' || card.val === 'Wild Table' || finalPenaltyCount > 0) updates["gameState.deck"] = gameDeck.map(serializeCard);
    
    if(newWinner !== -1) { 
        updates["gameState.gameActive"] = false; 
        updates["gameState.winnerIdx"] = newWinner; 
        let roundScores = newHands.map(h => h.reduce((sum, c) => sum + (c.type==='num'?parseInt(c.val):20), 0)); 
        updates["players"] = playerUpdates.map((p, i) => ({ ...p, score: p.score + roundScores[i], lastRoundScore: roundScores[i] })); 
    }
    await db.collection("rooms").doc(currentRoomId).update(updates);
    // NO SYSTEM LOG
}
async function serverPunishVulnerable(victimIdx) { 
    let newDeck = [...gameDeck], newHands = gameHands.map(h=>[...h]), c = newDeck.pop(); if(c) newHands[victimIdx].push(c); let pUpdates = [...gamePlayers]; pUpdates[victimIdx].hand = newHands[victimIdx].map(serializeCard); 
    await db.collection("rooms").doc(currentRoomId).update({ "players": pUpdates, "gameState.deck": newDeck.map(serializeCard), "gameState.vulnerablePlayerIdx": -1, "gameState.lastAction": { type: 'challenge', success: true, victimIdx: victimIdx, timestamp: Date.now() } }); 
}
async function serverPunishChallenger(challengerIdx) { 
    let newDeck = [...gameDeck], newHands = gameHands.map(h=>[...h]), c = newDeck.pop(); if(c) newHands[challengerIdx].push(c); let pUpdates = [...gamePlayers]; pUpdates[challengerIdx].hand = newHands[challengerIdx].map(serializeCard); pUpdates[challengerIdx].challengeUsed = true; let nextP = (currentPlayer + direction + 4) % 4; 
    await db.collection("rooms").doc(currentRoomId).update({ "players": pUpdates, "gameState.deck": newDeck.map(serializeCard), "gameState.currentPlayer": nextP, "gameState.hasDrawn": false, "gameState.lastAction": { type: 'challenge', success: false, victimIdx: challengerIdx, timestamp: Date.now() } }); 
}

async function nextRound() {
    if(!isHost) return;
    document.getElementById('end-modal').style.display = 'none';
    const newDeck = createFullDeck();
    const hands = [[], [], [], []];
    for(let i=0; i<7; i++) { for(let p=0; p<4; p++) hands[p].push(newDeck.pop()); }
    
    // SERIALIZE HANDS
    const updatedPlayers = gamePlayers.map((p, i) => ({ ...p, hand: hands[i].map(serializeCard), isReady: false, saidSonTabak: false, challengeUsed: false }));
    
    let first = newDeck.pop(); while(first.color === 'wild' || first.type === 'action') { newDeck.unshift(first); first = newDeck.pop(); }
    
    const nextState = { 
        deck: newDeck.map(serializeCard), 
        discardPile: [serializeCard(first)], 
        currentPlayer: lastWinner, direction: 1, drawStack: 0, gameActive: true, 
        lastAction: { type: 'newRound', timestamp: Date.now() }, 
        vulnerablePlayerIdx: -1, playerColors: playerColors, 
        hasDrawn: false 
    };
    await db.collection("rooms").doc(currentRoomId).update({ players: updatedPlayers, gameState: nextState, lastActive: Date.now() });
    // NO SYSTEM LOG
}

async function hostBotTurn() {
    try {
        if(!isHost) return;
        const currentPObj = gamePlayers[currentPlayer];
        if(!currentPObj || !currentPObj.isBot) return; 

        // TIMING BUG FIX: If bot just drew a penalty, stop! Wait for auto-pass.
        if (lastGameState && lastGameState.lastAction && 
            lastGameState.lastAction.type === 'draw' && 
            lastGameState.lastAction.pIdx === currentPlayer && 
            lastGameState.lastAction.isPenalty === true) {
            return; 
        }

        // 1. Challenge Check (Punish vulnerable)
        if(vulnerablePlayerIdx !== -1 && vulnerablePlayerIdx !== currentPlayer) {
            if(Math.random() < 0.95) { 
                await serverPunishVulnerable(vulnerablePlayerIdx);
                await wait(1500); 
            }
        }

        const hand = gameHands[currentPlayer];
        let willSaySonTabak = false;

        // BOT NEW LOGIC: Must play Number card if available
        let playableNums = hand.filter(c => c.type === 'num' && canPlay(c));
        let playableSpecials = hand.filter(c => c.type !== 'num' && canPlay(c));

        if(playableNums.length > 0) {
            // Must play a number
            let cardToPlay = playableNums[Math.floor(Math.random() * playableNums.length)];
            let cardIdx = hand.indexOf(cardToPlay);
            
            if(hand.length === 2) { // 2 cards before play means 1 card left after
                 if(Math.random() > 0.1) { await serverBotSaySonTabak(currentPlayer); willSaySonTabak = true; }
            }
            
            await serverPlayCard(currentPlayer, cardIdx, cardToPlay, 1, willSaySonTabak);
            return;
        }

        // If no numbers, handle special cases (Draw Stack)
        if (drawStack > 0) {
            // If has specials like +2 or Wild Meze (Already filtered into playableSpecials)
            if(playableSpecials.length > 0) {
                 let cardToPlay = playableSpecials[Math.floor(Math.random() * playableSpecials.length)];
                 let cardIdx = hand.indexOf(cardToPlay);
                 
                 // Handle Color Choice (Smart Choice)
                 if(cardToPlay.color === 'wild') {
                     if(cardToPlay.val === 'Wild Anti-Draw') {
                         let top = gameDiscard[gameDiscard.length-1];
                         cardToPlay.chosenColor = top.chosenColor || top.color;
                         if(cardToPlay.chosenColor === 'wild') cardToPlay.chosenColor = 'red';
                     } else {
                         // Pick most frequent color in hand
                         let counts = {red:0, green:0, yellow:0, purple:0};
                         hand.forEach(c => { if(c.color !== 'wild') counts[c.color]++; });
                         cardToPlay.chosenColor = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                     }
                 }
                 
                 await serverPlayCard(currentPlayer, cardIdx, cardToPlay, 1, willSaySonTabak);
            } else {
                 await serverDrawCard(currentPlayer, drawStack, true); 
                 setTimeout(() => serverPassTurn(currentPlayer), 1500 + (drawStack*600)); 
            }
            return;
        }

        // No numbers, normal turn. Decide to play special or Draw (Hoarding)
        // If has Drawn, check the drawn card
        if (hasDrawn) {
            // Check last card in hand
            if(hand.length > 0) {
                let lastCard = hand[hand.length - 1];
                if(lastCard.type === 'num' && canPlay(lastCard)) {
                    // Must play drawn number
                    let cardIdx = hand.length - 1;
                    if(hand.length === 2 && Math.random() > 0.1) { await serverBotSaySonTabak(currentPlayer); willSaySonTabak = true; }
                    await serverPlayCard(currentPlayer, cardIdx, lastCard, 1, willSaySonTabak);
                } else {
                    // Pass turn (Keep special or unplayable card)
                    await serverPassTurn(currentPlayer);
                }
            } else {
                await serverPassTurn(currentPlayer);
            }
            return;
        }

        // Has not drawn yet. No numbers.
        if (playableSpecials.length > 0) {
            // SMART BOT: Check opponents' hand sizes
            let minOpponentHand = 100;
            for(let i=0; i<4; i++) { if(i !== currentPlayer) minOpponentHand = Math.min(minOpponentHand, gameHands[i].length); }

            let hoardProb = 0.6; 
            // If opponents are about to win (<= 2 cards), DUMP Wilds (20pts) to reduce penalty
            if(minOpponentHand <= 2) hoardProb = 0.1; 

            // 60% chance to play special normally, 40% chance to hoard/draw
            if(Math.random() > hoardProb || minOpponentHand <= 2) {
                // Prioritize MIXER or TABLE or Wilds (High Points) if losing
                let priorityCard = null;
                
                if(minOpponentHand <= 2) {
                    // Dump high value wilds
                    priorityCard = playableSpecials.find(c => c.color === 'wild');
                }
                
                let cardToPlay = priorityCard || playableSpecials[Math.floor(Math.random() * playableSpecials.length)];
                let cardIdx = hand.indexOf(cardToPlay);
                let mixDir = 1;

                // Handle Wild Logic
                if(cardToPlay.color === 'wild') {
                     if(cardToPlay.val === 'Wild Anti-Draw') {
                         let top = gameDiscard[gameDiscard.length-1];
                         cardToPlay.chosenColor = top.chosenColor || top.color;
                         if(cardToPlay.chosenColor === 'wild') cardToPlay.chosenColor = 'red';
                     } else {
                         // Smart Color Pick
                         let counts = {red:0, green:0, yellow:0, purple:0};
                         hand.forEach(c => { if(c.color !== 'wild') counts[c.color]++; });
                         cardToPlay.chosenColor = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                     }

                     // Smart Mixer Logic (Comparison)
                     if(cardToPlay.val === 'Wild Mixer') {
                         let leftIdx = (currentPlayer + 3) % 4;
                         let rightIdx = (currentPlayer + 1) % 4;
                         let leftCount = gameHands[leftIdx].length;
                         let rightCount = gameHands[rightIdx].length;
                         let myCount = hand.length;
                         
                         // Determine targets
                         // Default Right (1). Right player gives hand to me? No, Swap logic in Mixer:
                         // if dir=1: P1 takes P0 (Right neighbor takes Me). Wait.
                         // Let's look at logic: if(newDir === 1) { let temp = newHands[3]; ... newHands[1] = newHands[0]; }
                         // P1 gets P0's hand. (Right neighbor gets My hand).
                         // So I (P0) get P3's hand (Left neighbor).
                         
                         // So: Dir 1 (Right) => I take Left Neighbor's hand.
                         // Dir -1 (Left) => I take Right Neighbor's hand.

                         let targetCountRight = rightCount; // if dir -1
                         let targetCountLeft = leftCount; // if dir 1

                         if(targetCountRight < myCount && targetCountRight < targetCountLeft) {
                             mixDir = -1; // Take Right hand
                         } else if (targetCountLeft < myCount) {
                             mixDir = 1; // Take Left hand
                         } else {
                             // Both have more cards than me? 
                             // If I'm forced to play Mixer (only card), keep default. 
                             // If I had a choice, I wouldn't be here (hoard logic).
                             // But if minOpponentHand <= 2, I am dumping points.
                             mixDir = 1;
                         }
                     }
                }

                if(hand.length === 2 && Math.random() > 0.1) { await serverBotSaySonTabak(currentPlayer); willSaySonTabak = true; }
                await serverPlayCard(currentPlayer, cardIdx, cardToPlay, mixDir, willSaySonTabak);
            } else {
                await serverDrawCard(currentPlayer, 1);
                // Next tick will handle the drawn card logic above
            }
        } else {
            // Nothing playable
            await serverDrawCard(currentPlayer, 1);
        }

    } catch(e) {
        console.error("Bot Logic Error:", e);
        throw e;
    }
}

async function serverBotSaySonTabak(pIdx) {
    let pUpdates = [...gamePlayers]; pUpdates[pIdx].saidSonTabak = true;
    let pColor = playerColors[pIdx];
    await db.collection("rooms").doc(currentRoomId).update({ players: pUpdates, "gameState.vulnerablePlayerIdx": -1, "gameState.lastAction": { type: 'sonTabak', pIdx: pIdx, timestamp: Date.now() }});
    // NO SYSTEM LOG
}

/* --- YARDIMCI G√ñRSELLER & ANƒ∞MASYONLAR --- */
function updateUI() {
    if(myPlayerIdx === -1) return;
    let aL = document.getElementById('arrow-left'), aR = document.getElementById('arrow-right'), aT1 = document.getElementById('arrow-top-1'), aT2 = document.getElementById('arrow-top-2');
    aL.className = 'arrow-icon'; aR.className = 'arrow-icon'; aT1.className = 'arrow-top-static'; aT2.className = 'arrow-top-static';

    if(direction === 1) { aL.innerText = '‚¨ÜÔ∏è'; aR.innerText = '‚¨áÔ∏è'; aT1.innerText = '‚û°Ô∏è'; aT2.innerText = '‚û°Ô∏è'; } else { aL.innerText = '‚¨áÔ∏è'; aR.innerText = '‚¨ÜÔ∏è'; aT1.innerText = '‚¨ÖÔ∏è'; aT2.innerText = '‚¨ÖÔ∏è'; }
    if(gameActive) {
        let topCard = gameDiscard[gameDiscard.length-1]; let activeColor = topCard ? (topCard.chosenColor || topCard.color) : null; if(activeColor === 'wild') activeColor = 'neutral';
        let glowClass = activeColor ? `glow-${activeColor}` : '';
        let relCurrent = (currentPlayer - myPlayerIdx + 4) % 4, relNext = ((currentPlayer+direction+4)%4 - myPlayerIdx + 4) % 4;
        let tArr = null;
        if((relCurrent===0 && relNext===1) || (relCurrent===1 && relNext===0)) tArr = aL;
        if((relCurrent===1 && relNext===2) || (relCurrent===2 && relNext===1)) tArr = aT1;
        if((relCurrent===2 && relNext===3) || (relCurrent===3 && relNext===2)) tArr = aT2;
        if((relCurrent===3 && relNext===0) || (relCurrent===0 && relNext===3)) tArr = aR;
        if(tArr && glowClass) tArr.classList.add('active', glowClass);
    }

    if(gameDeck) document.getElementById('deck-count').innerText = gameDeck.length;
    let pBadge = document.getElementById('penalty-badge');
    if(drawStack > 0) { pBadge.innerText = "+" + drawStack; pBadge.style.display = 'flex'; pBadge.className = `p-${Math.min(drawStack,6)}`; } else pBadge.style.display = 'none';

    let sortedP = [...gamePlayers].sort((a,b)=>a.score - b.score);
    let html = "";
    sortedP.forEach(p => {
         let color = playerColors[gamePlayers.findIndex(x => x.uid===p.uid)] || '#333';
         let isMe = p.uid === myUid;
         html += `<tr class="${isMe?'me-row':''}"><td style="color:${color}; font-weight:${isMe?'900':'normal'};">${p.name}</td><td style="text-align:right;">${p.score}</td></tr>`;
    });
    document.getElementById('score-table').querySelector('tbody').innerHTML = html;

    let dp = document.getElementById('discard-pile');
    if(gameDiscard.length > 0) {
        let c = gameDiscard[gameDiscard.length-1];
        dp.innerHTML = createCardHTML(c);
        let activeColor = c.chosenColor || c.color;
        let cont = document.querySelector('.game-container');
        cont.classList.remove('ambient-red', 'ambient-green', 'ambient-yellow', 'ambient-purple');
        if(activeColor !== 'wild') cont.classList.add(`ambient-${activeColor}`);
    }

    if (!isDealing) {
        let ph = document.getElementById('player-hand'); ph.innerHTML = '';
        if(currentPlayer === myPlayerIdx) ph.classList.add('current-player-area'); else ph.classList.remove('current-player-area');
        gameHands[myPlayerIdx].forEach((c, idx) => {
            let div = document.createElement('div'); div.innerHTML = createCardHTML(c); let el = div.firstElementChild;
            if(currentPlayer === myPlayerIdx && canPlay(c)) { el.classList.add('playable'); el.onclick = () => playerPlayCard(idx); } else el.style.opacity = 0.6;
            ph.appendChild(el);
        });
    }

    const visualIndices = [ (myPlayerIdx + 1) % 4, (myPlayerIdx + 2) % 4, (myPlayerIdx + 3) % 4 ];
    for(let i=0; i<3; i++) {
        let realIdx = visualIndices[i]; let p = gamePlayers[realIdx]; let elId = `bot${i+1}`;
        if(p) {
            let pColor = playerColors[realIdx] || '#333';
            // Use deserialized hand length
            let handLen = p.hand ? p.hand.length : 0;
            document.getElementById(`${elId}-name`).innerHTML = `<span style="color:${pColor}">${p.name}</span> (${handLen})`;
            let stack = document.getElementById(`${elId}-stack`); stack.innerHTML = "";
            let visibleCount = Math.min(handLen, 6);
            let totalW = 60 + (visibleCount > 0 ? (visibleCount-1)*8 : 0);
            stack.style.width = totalW + 'px';
            for(let j=0; j<visibleCount; j++) {
                let mc = document.createElement('div'); mc.className = 'mini-card-back'; mc.style.top = (j*4)+'px'; mc.style.left = (j*8)+'px'; stack.appendChild(mc);
            }
            if(currentPlayer === realIdx) document.getElementById(`${elId}-wrapper`).classList.add('current-player'); else document.getElementById(`${elId}-wrapper`).classList.remove('current-player');
        }
    }

    let stBtn = document.getElementById('son-tabak-btn');
    stBtn.disabled = !(currentPlayer === myPlayerIdx && gameHands[myPlayerIdx].length <= 2 && !gamePlayers[myPlayerIdx].saidSonTabak);
    let chBtn = document.getElementById('challenge-btn');
    // DISABLED IF DRAW STACK > 0 (Penalty Active)
    chBtn.disabled = !(currentPlayer === myPlayerIdx && !gamePlayers[myPlayerIdx].challengeUsed && drawStack === 0);
}

function animateFly(from, to, html, callback) {
    if(!from || !to) { if(callback) callback(); return; }
    let f = from.getBoundingClientRect(); let t = to.getBoundingClientRect();
    let el = document.createElement('div');
    if(html) { let w = document.createElement('div'); w.innerHTML = html; el = w.firstElementChild; el.classList.add('flying-card'); } else { el.className = 'card card-back-style flying-card'; }
    
    // START CENTERED
    let startX = f.left + f.width/2 - 52; 
    let startY = f.top + f.height/2 - 77;
    
    // END CENTERED
    let endX = t.left + t.width/2 - 52; 
    let endY = t.top + t.height/2 - 77;
    
    // SOFRA FIX: If from='play-area' (table center)
    if(from.id === 'play-area') {
        let pa = document.getElementById('play-area').getBoundingClientRect();
        startX = pa.left + pa.width/2 - 52;
        startY = pa.top + pa.height/2 - 77;
    }
    
    el.style.left = startX + 'px'; 
    el.style.top = startY + 'px'; 
    document.body.appendChild(el);
    
    void el.offsetWidth; 
    
    el.style.left = endX + 'px'; 
    el.style.top = endY + 'px'; 
    
    setTimeout(() => { el.remove(); if(callback) callback(); }, ANIM_CONFIG.FLY_BUFFER);
}
function animateReverse() { 
    return new Promise(resolve => {
        document.querySelectorAll('.arrow-icon').forEach(el => { el.classList.add('arrow-spin'); });
        document.querySelectorAll('.arrow-top-static').forEach(el => { el.classList.add('arrow-spin'); });
        setTimeout(() => { 
            document.querySelectorAll('.arrow-icon').forEach(el => { el.classList.remove('arrow-spin'); }); 
            document.querySelectorAll('.arrow-top-static').forEach(el => { el.classList.remove('arrow-spin'); }); 
            resolve(); 
        }, 1200);
    });
}
function animateBlock(pIdx) {
    let victimIdx = (pIdx + direction + 4) % 4;
    // FIXED: Target the card STACK for bots to center animation correctly
    let targetId = victimIdx === myPlayerIdx ? 'player-hand' : `bot${(victimIdx - myPlayerIdx + 4) % 4}-stack`;
    let el = document.getElementById(targetId);
    if(el) {
        let b = document.createElement('div'); b.innerText = 'üî™'; b.className = 'blocked-anim';
        let r = el.getBoundingClientRect(); b.style.left = r.left+(r.width/2)+'px'; b.style.top = r.top+(r.height/2)+'px';
        document.body.appendChild(b); setTimeout(()=>b.remove(),2000);
    }
}
function animateTableEffect() {
    return new Promise(resolve => {
        let centerEl = document.getElementById('play-area'); let rect = centerEl.getBoundingClientRect();
        let centerX = rect.left + rect.width/2; let centerY = rect.top + rect.height/2;
        let animCards = [];
        ['player-hand','bot1-wrapper','bot2-wrapper','bot3-wrapper'].forEach(id => {
            let el = document.getElementById(id); if(el) {
                let r = el.getBoundingClientRect();
                // FIX: Start form center of element
                let startX = r.left + r.width/2 - 30; // Approx half card width
                let startY = r.top + r.height/2 - 45; // Approx half card height

                for(let k=0; k<3; k++) {
                    let ac = document.createElement('div'); ac.className = 'mini-card-back'; 
                    ac.style.zIndex = 5000; ac.style.left = startX + 'px'; ac.style.top = startY + 'px';
                    document.body.appendChild(ac); animCards.push(ac);
                }
            }
        });
        setTimeout(() => {
            animCards.forEach(ac => { ac.style.transition = 'all 1.2s ease-in-out'; ac.style.left = (centerX - 30) + 'px'; ac.style.top = (centerY - 45) + 'px'; ac.style.transform = 'rotate(720deg)'; });
        }, 50);
        setTimeout(() => { 
            animCards.forEach(ac => { let angle = Math.random() * Math.PI * 2; let dist = 400; ac.style.left = (centerX + Math.cos(angle)*dist) + 'px'; ac.style.top = (centerY + Math.sin(angle)*dist) + 'px'; ac.style.opacity = 0; });
            setTimeout(() => { animCards.forEach(ac => ac.remove()); resolve(); }, 1200);
        }, 1500);
    });
}
function animateMixerEffect(dir) {
    return new Promise(resolve => {
        let dp = document.getElementById('play-area'); let rect = dp.getBoundingClientRect();
        let cx = rect.left + rect.width/2; let cy = rect.top + rect.height/2;
        let mixerContainer = document.createElement('div'); mixerContainer.className = 'mixer-container'; mixerContainer.style.left = cx + 'px'; mixerContainer.style.top = cy + 'px';
        document.body.appendChild(mixerContainer);
        // FIX: Reduced radius (-40px instead of -70px)
        for(let i=0; i<8; i++) {
            let c = document.createElement('div'); c.className = 'mixer-card card-back-style'; c.style.transform = `rotate(${(i/8)*360}deg) translateY(-40px)`; mixerContainer.appendChild(c);
        }
        setTimeout(() => { mixerContainer.style.transition = 'transform 2s ease-in-out'; mixerContainer.style.transform = `rotate(${dir * 720}deg)`; }, 100);
        setTimeout(() => { mixerContainer.remove(); resolve(); }, 2200);
    });
}
function animatePotEffect(senderIdx, dir) {
    let source = document.getElementById('draw-pile');
    for(let k=0; k<4; k++) {
        let targetPIdx = (senderIdx + (k * dir) + 4) % 4;
        let targetId = targetPIdx === myPlayerIdx ? 'player-hand' : `bot${(targetPIdx - myPlayerIdx + 4) % 4}-wrapper`;
        setTimeout(() => { 
            animateFly(source, document.getElementById(targetId), null); 
        }, k * ANIM_CONFIG.DRAW_INTERVAL);
    }
}
function animateMezeEffect(senderIdx) {
    let prevIdx = (senderIdx - direction + 4) % 4;
    let targetId = prevIdx === myPlayerIdx ? 'player-hand' : `bot${(prevIdx - myPlayerIdx + 4) % 4}-wrapper`;
    animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null);
}
async function animateInitialDeal() {
    let piles = [];
    isDealing = true; 
    document.getElementById('player-hand').innerHTML = '';
    
    let targets = ['player-hand', 'bot1-wrapper', 'bot2-wrapper', 'bot3-wrapper'];
    let myHandClone = [...gameHands[myPlayerIdx]]; 
    let myCardIndex = 0;

    for(let round=0; round<7; round++) {
        for(let p=0; p<4; p++) {
            let targetId = targets[p];
            let cardHtml = null;
            if (p === 0 && myCardIndex < myHandClone.length) {
                cardHtml = createCardHTML(myHandClone[myCardIndex]);
            }

            animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), cardHtml, () => {
                if (p === 0 && cardHtml) {
                    let div = document.createElement('div'); 
                    div.innerHTML = cardHtml; 
                    let el = div.firstElementChild;
                    el.style.opacity = 0.6; 
                    document.getElementById('player-hand').appendChild(el);
                }
            });
            if(p===0) myCardIndex++;
            await wait(ANIM_CONFIG.INITIAL_DEAL); 
        }
    }
    document.getElementById('player-hand').innerHTML = '';
    isDealing = false; 
    updateUI();
}
function startVegetableRain() {
    const canvas = document.getElementById('confetti-canvas'); const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const emojis = ['ü•¶', 'üçÖ', 'ü•î', 'üçÜ']; let drops = [];
    for(let i=0; i<30; i++) drops.push({x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20});
    let isActive = true; setTimeout(() => isActive=false, 4000);
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(isActive && Math.random() < 0.3) drops.push({x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20});
        for (let i = 0; i < drops.length; i++) {
            let d = drops[i]; ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.rot * Math.PI / 180); ctx.font = `${d.size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(d.emoji, 0, 0); ctx.restore();
            d.y += d.vy; d.x += d.vx + Math.sin(d.y / 50) * 0.5; d.rot += d.rotSpeed;
            if (d.y > canvas.height + 50) { if(isActive) drops[i] = {x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20}; else { drops.splice(i, 1); i--; } }
        }
        if (drops.length > 0 || isActive) requestAnimationFrame(animate); else ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    animate();
}

function openRules() { document.getElementById('rules-modal').style.display = 'flex'; }
function leaveGame() { document.getElementById('leave-modal').style.display = 'flex'; }
function confirmLeaveGame() {
    if(!currentRoomId) return; 
    
    if(roomUnsubscribe) roomUnsubscribe();
    if(gameChatUnsub) gameChatUnsub(); // Unsubscribe Chat
    if(heartbeatInterval) clearInterval(heartbeatInterval);
    if(botInterval) clearInterval(botInterval); // Clean up watchdog
    
    updateGlobalStatus('lobby'); // Reset Status to Lobby

    // UI Reset - FORCE HIDE ALL GAME SCREENS
    document.getElementById('main-game-wrapper').style.display = 'none';
    document.getElementById('waiting-room-overlay').style.display = 'none';
    document.getElementById('leave-modal').style.display = 'none';
    document.getElementById('end-modal').style.display = 'none';
    
    // SHOW LOBBY
    document.getElementById('lobby-overlay').style.display = 'flex';

    db.collection("rooms").doc(currentRoomId).get().then(doc => {
        if(!doc.exists) { 
             currentRoomId = null; isHost = false;
             return; 
        }
        let ps = doc.data().players || [];
        let rData = doc.data();
        let isPlaying = rData.status === 'playing';

        if(ps.length <= 1) {
            deleteFullRoom(currentRoomId)
                .catch(e => console.log("Room delete error", e))
                .finally(() => { currentRoomId = null; isHost = false; });
        } else {
            let newPs;
            if(isPlaying) {
                newPs = ps.map(p => {
                    if(p.uid === myUid) {
                        return {
                            ...p,
                            uid: 'replaced_bot_' + Date.now(),
                            name: 'ü§ñ ' + p.name,
                            isBot: true,
                            isReady: true,
                            lastSeen: Date.now()
                        };
                    }
                    return p;
                });
            } else {
                newPs = ps.filter(p => p.uid !== myUid);
            }
            
            db.collection("rooms").doc(currentRoomId).update({ players: newPs })
                .catch(e => console.log("Leave update error", e))
                .finally(() => { currentRoomId = null; isHost = false; });
        }
    });
    
    // Reset Game State Variables
    localPlayers = [];
    gameHands = [];
    gameDeck = [];
    actionQueue = [];
    isProcessingQueue = false;
    previousPlayersList = [];
}

/* --- UTILS --- */
const VEGETABLES = { red: 'üçÖ', green: 'ü•¶', yellow: 'ü•î', purple: 'üçÜ' };
const SPECIALS = { '+1': 'üì¶', '+2': 'üì¶üì¶', 'Reverse': '‚ôªÔ∏è', 'Block': 'üî™', 'Wild': 'GUVEC', 'Wild Anti-Draw': 'üßª', 'Wild Pot': 'üç≤', 'Wild Table': 'üçΩÔ∏è', 'Wild Mixer': 'üå™Ô∏è', 'Wild Meze': 'üç±' };
function createCardHTML(card) {
    if(!card) return ""; // Handle null/undefined during transitions
    let emoji = (card.type === 'num') ? VEGETABLES[card.color] : (card.val === 'Wild' ? `<div class="guvec-grid"><span>üçÖ</span><span>ü•¶</span><span>ü•î</span><span>üçÜ</span></div>` : (SPECIALS[card.val] || card.val));
    let cls = (card.color === 'wild') ? 'wild-bg' : card.color;
    let borderStyle = card.chosenColor ? `border-color: ${card.chosenColor==='red'?'#e74c3c':card.chosenColor==='green'?'#2ecc71':card.chosenColor==='yellow'?'#f39c12':'#9b59b6'} !important; border-width: 3px;` : '';
    let cornerTxt = (card.type === 'num') ? card.val : '';
    return `<div class="card ${cls}" style="${borderStyle}" data-val="${card.val}"><div class="card-corner top-left">${cornerTxt}</div><div class="card-emoji">${emoji}</div><div class="card-corner bottom-right">${cornerTxt}</div></div>`;
}
function openPatternModal() { 
    const grid = document.getElementById('pattern-grid'); grid.innerHTML = ''; 
    CARD_PATTERNS.forEach(p => { 
        let d = document.createElement('div'); 
        d.className = 'pattern-opt'; 
        d.style.background = p; 
        d.onclick = () => { 
            document.documentElement.style.setProperty('--card-pattern', p);
            currentPattern = p; 
            updateUI(); 
            closePatternModal(); 
        }; 
        grid.appendChild(d); 
    }); 
    document.getElementById('pattern-modal').style.display = 'flex'; 
}
function closePatternModal() { document.getElementById('pattern-modal').style.display = 'none'; }
function handleChatKey(e) { if(e.key === 'Enter') playerSendMessage(); }
function toggleReadyState() { if(!currentRoomId) return; amIReady = !amIReady; let btn = document.getElementById('end-continue-btn'); btn.innerText = amIReady ? "Bekleniyor..." : "Devam Et ‚è≥"; btn.classList.toggle('btn-blue'); btn.classList.toggle('btn-dark'); let ps = [...gamePlayers]; let meIdx = ps.findIndex(p => p.uid === myUid); if(meIdx !== -1) { ps[meIdx].isReady = amIReady; db.collection("rooms").doc(currentRoomId).update({ players: ps, lastActive: Date.now() }); } }

const cleanupRoom = async () => { 
    if(heartbeatInterval) clearInterval(heartbeatInterval); 
    if(botInterval) clearInterval(botInterval);
};

function shuffleDeck(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
function createFullDeck() { let d = []; ['red','green','yellow','purple'].forEach(c => { d.push({color:c,val:'0',type:'num',name:'0'}); for(let i=1; i<=9; i++) d.push({color:c,val:i.toString(),type:'num',name:i}); ['+1','Reverse','Block'].forEach(v=>d.push({color:c,val:v,type:'action',name:v})); }); for(let i=0;i<2;i++) { d.push({color:'wild',val:'Wild',type:'wild',name:'G√ºve√ß'}); d.push({color:'wild',val:'+2',type:'wild',name:'+2'}); d.push({color:'wild',val:'Wild Anti-Draw',type:'wild',name:'Tuvalet Kaƒüƒ±dƒ±'}); d.push({color:'wild',val:'Wild Pot',type:'wild',name:'D√ºd√ºkl√º Tencere'}); d.push({color:'wild',val:'Wild Meze',type:'wild',name:'Meze'}); } d.push({color:'wild',val:'Wild Table',type:'wild',name:'Sofra'}); d.push({color:'wild',val:'Wild Mixer',type:'wild',name:'Mikser'}); return shuffleDeck(d); }
function showSonTabakPopup(name) { let p = document.getElementById('son-tabak-popup'); document.getElementById('son-tabak-who').innerText = name + " dedi!"; p.style.display = 'block'; setTimeout(() => p.style.display = 'none', ANIM_CONFIG.POPUP); }
function showChallengePopup(success, title, detail) { 
    let p = document.getElementById('challenge-popup'); 
    document.getElementById('challenge-who').innerText = title || "ƒ∞Tƒ∞RAZ!"; 
    document.getElementById('challenge-result').innerText = detail || (success ? "BA≈ûARILI! ‚úÖ" : "HATALI! ‚ùå"); 
    p.className = success ? 'challenge-valid' : 'challenge-invalid'; 
    p.style.display = 'block'; 
    setTimeout(() => p.style.display = 'none', ANIM_CONFIG.POPUP); 
}
function addChatLog(name, msg, color) { 
    const chatDiv = document.getElementById('chat-messages'); 
    const msgDiv = document.createElement('div'); 
    msgDiv.className = `chat-line`; 
    msgDiv.innerHTML = `<span class="chat-name" style="color:${color}; font-weight:bold;">${name}:</span><span class="chat-text">${msg}</span>`; 
    chatDiv.appendChild(msgDiv); 
    
    // LIMIT CHANGE: 50 -> 10
    while(chatDiv.childElementCount > 10) chatDiv.removeChild(chatDiv.firstChild); 
    
    chatDiv.scrollTop = chatDiv.scrollHeight; 
}
function showToast(msg) { let t = document.getElementById('toast'); t.innerText = msg; t.style.display = 'block'; setTimeout(() => t.style.display = 'none', ANIM_CONFIG.TOAST); }
function showEndGame(winnerIdx, finalPlayers) {
    lastWinner = winnerIdx;
    const winnerName = finalPlayers[winnerIdx].name;

    // --- SPƒ∞KER G√úNCELLEMESƒ∞ (BA≈ûLANGI√á) ---
    // Bu elde en √ßok ceza puanƒ± yiyen oyuncuyu bul
    let maxRoundScore = -1;
    let worstRoundPlayerName = "";
    
    finalPlayers.forEach(p => {
        // lastRoundScore undefined olabilir, kontrol et
        let s = p.lastRoundScore || 0;
        if(s > maxRoundScore) {
            maxRoundScore = s;
            worstRoundPlayerName = p.name;
        }
    });

    let comments = [
        `Vay vay vay! ${winnerName} resmen masayƒ± s√ºp√ºrd√º!`,
        `ƒ∞nanƒ±lmaz bir final! ${winnerName} rakiplerine nefes aldƒ±rmadƒ±.`,
        `Sebzeler havada u√ßu≈ütu ama ${winnerName} tabaƒüƒ±nƒ± bitiren ilk isim oldu!`,
        `Bu ne hƒ±z ${winnerName}? Rakiplerin masaya daha yeni oturdu!`,
        `Tarihi bir an! Kazanan ${winnerName} oldu.`,
        `${winnerName} mutfaƒüƒ±n efendisi olduƒüunu kanƒ±tladƒ±!`,
        `≈ûefin tavsiyesi: ${winnerName}!`
    ];
    
    let roasts = [
        `${worstRoundPlayerName} ise bu elin oburu oldu ve bir elde ${maxRoundScore} puan yedi!`,
        `${worstRoundPlayerName}, bu el market alƒ±≈üveri≈üine √ßƒ±kmƒ±≈ü gibisin, ${maxRoundScore} puan ne?!`,
        `Sanƒ±rƒ±m ${worstRoundPlayerName} oyunu yanlƒ±≈ü anladƒ±, ama√ß kart toplamak deƒüil atmaktƒ±!`,
        `${worstRoundPlayerName} i√ßin bir dakikalƒ±k saygƒ± duru≈üu... Bu el √ßok canƒ± yandƒ±.`,
        `${worstRoundPlayerName} bu gidi≈üle bula≈üƒ±klarƒ± yƒ±kayacak gibi duruyor.`,
        `${worstRoundPlayerName} elindeki kartlarla artƒ±k kule yapabilir.`
    ];

    let randomComment = comments[Math.floor(Math.random() * comments.length)];
    let randomRoast = roasts[Math.floor(Math.random() * roasts.length)];

    document.getElementById('winner-text').innerText = `üéâ ${winnerName} Kazandƒ±!`;
    document.getElementById('ai-summary').innerHTML = `üé§ <b>Spiker:</b> "${randomComment} ${randomRoast}"`;
    // --- SPƒ∞KER G√úNCELLEMESƒ∞ (Bƒ∞Tƒ∞≈û) ---

    document.getElementById('end-modal').style.display = 'flex';
    updateReadyStatusUI(); startVegetableRain(); SoundFX.playFanfare();
}
function updateReadyStatusUI() {
    let allReady = true; gamePlayers.forEach(p => { if(!p.isBot && !p.isReady) allReady = false; });
    let sortedP = [...gamePlayers].sort((a,b)=>a.score - b.score);
    let html = `<table style="width:100%; border-collapse:collapse;">`; 
    sortedP.forEach(p => { 
        let isMe = p.uid === myUid; 
        let pColor = playerColors[gamePlayers.findIndex(x=>x.uid===p.uid)] || '#333';
        let lastRoundScore = p.lastRoundScore !== undefined ? `+${p.lastRoundScore}` : '';
        html += `<tr style="${isMe ? 'background-color: #fff9c4; font-weight: bold; border-left: 4px solid #f1c40f;' : ''}">
                    <td style="padding: 8px 10px; border-bottom: 1px solid #eee; color:${pColor};">${p.name}</td>
                    <td style="padding: 8px 10px; border-bottom: 1px solid #eee; text-align:right;">
                        <span style="color:#e74c3c; font-size:0.9em; margin-right:5px;">${lastRoundScore}</span>
                        (Toplam: ${p.score}) ${(p.isReady||p.isBot)?'‚úÖ':'‚è≥'}
                    </td>
                 </tr>`; 
    });
    html += `</table>`;
    document.getElementById('final-scores').innerHTML = html;
    if(isHost) document.getElementById('host-start-btn').style.display = allReady ? 'block' : 'none';
}
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
</script>
</body>
</html>
