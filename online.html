<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Son Tabak Online - v5.7 Animation Polish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <!-- FIREBASE (Compat S√ºr√ºmleri) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>

    <style>
        /* --- STƒ∞L DOSYASI --- */
        :root {
            /* Varsayƒ±lan Turuncu */
            --card-pattern: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
        }

        body { font-family: 'Segoe UI', sans-serif; background-color: #2c3e50; color: #333; margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; user-select: none; -webkit-tap-highlight-color: transparent; }
        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; }
        
        #lobby-overlay, #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2c3e50; z-index: 7000; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; }
        .lobby-box { background: white; color: #333; padding: 30px; border-radius: 15px; width: 90%; max-width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-height: 80vh; overflow-y: auto; }
        .room-item { border: 1px solid #ddd; padding: 10px; margin: 5px 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: 0.2s; }
        .room-item:hover { background: #f0f0f0; }
        .player-list { list-style: none; padding: 0; margin: 10px 0; }
        .player-item { padding: 5px; border-bottom: 1px dashed #eee; display: flex; justify-content: space-between; }
        
        .main-wrapper { display: grid; width: 98%; max-width: 1400px; height: 98vh; gap: 10px; padding: 5px; box-sizing: border-box; grid-template-columns: 1fr 300px; grid-template-rows: auto 1fr; grid-template-areas: "game logo" "game panel"; }
        #brand-area { grid-area: logo; text-align: center; background: #fff; padding: 10px; border-radius: 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: center; height: fit-content; }
        .brand-title { font-size: 1.5em; font-weight: 900; color: #2c3e50; line-height: 1; }
        .version { font-size: 0.4em; color: #95a5a6; margin-left: 5px; font-weight: normal; }
        .brand-sub { font-size: 1.2em; font-weight: bold; color: #e67e22; margin-top: 5px; letter-spacing: -1px; }

        .right-panel { grid-area: panel; display: flex; flex-direction: column; gap: 10px; height: 100%; overflow: hidden; }
        .flip-container { background-color: transparent; width: 100%; height: 200px; perspective: 1000px; cursor: pointer; flex-shrink: 0; }
        .flip-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
        .flip-container.flipped .flip-inner { transform: rotateY(180deg); }
        .flip-front, .flip-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; background: #fff; border-radius: 15px; overflow: hidden; display: flex; flex-direction: column; }
        .flip-back { transform: rotateY(180deg); background: #fdfdfd; }
        .panel-header { font-weight: bold; color: #fff; background: #34495e; padding: 5px; font-size: 0.9em; display: flex; justify-content: space-between; align-items: center; padding-left: 10px; padding-right: 10px;}
        
        #score-table { width: 100%; font-size: 0.85em; border-collapse: collapse; margin-top: 5px; table-layout: fixed; }
        #score-table tr { display: table-row; }
        #score-table td { padding: 8px 10px; border-bottom: 1px solid #eee; text-align: left; vertical-align: middle; }
        .me-row { background-color: #fff9c4; font-weight: bold; border-left: 4px solid #f1c40f; }

        #system-log { overflow-y: auto; flex-grow: 1; font-size: 0.75em; text-align: left; padding: 5px; list-style: none; margin: 0; }
        #system-log li { padding: 3px 0; border-bottom: 1px dashed #eee; color: #555; }
        .chat-container { background: #fff; border-radius: 15px; box-shadow: 0 3px 10px rgba(0,0,0,0.2); flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #chat-messages { flex-grow: 1; overflow-y: auto; padding: 10px; font-size: 0.85em; display: flex; flex-direction: column; gap: 4px; background: #fcfcfc; text-align: left;}
        .chat-line { line-height: 1.4; border-bottom: 1px solid #eee; padding-bottom: 2px;}
        .chat-input-area { display: flex; padding: 5px; border-top: 1px solid #eee; box-sizing: border-box; width: 100%; }
        #player-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 20px; padding: 5px 10px; font-size: 0.8em; outline: none; min-width: 0; }
        #send-btn { background: #3498db; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; margin-left: 5px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 1.2em; flex-shrink: 0; }

        .game-container { grid-area: game; background: #ecf0f1; border-radius: 20px; box-shadow: 0 15px 40px rgba(0,0,0,0.7); display: grid; grid-template-rows: auto 1fr auto; align-items: center; justify-items: center; position: relative; overflow: hidden; padding: 10px 0; background-color: #fdfbf7; background-image: repeating-linear-gradient(90deg, transparent, transparent 50px, rgba(231, 76, 60, 0.10) 50px, rgba(231, 76, 60, 0.10) 100px), repeating-linear-gradient(0deg, transparent, transparent 50px, rgba(231, 76, 60, 0.10) 50px, rgba(231, 76, 60, 0.10) 100px); transition: box-shadow 0.5s; border: 4px solid transparent; }
        .ambient-red { box-shadow: inset 0 0 60px rgba(231, 76, 60, 0.4) !important; border-color: #c0392b !important; }
        .ambient-green { box-shadow: inset 0 0 60px rgba(46, 204, 113, 0.4) !important; border-color: #27ae60 !important; }
        .ambient-yellow { box-shadow: inset 0 0 60px rgba(241, 196, 15, 0.4) !important; border-color: #f39c12 !important; }
        .ambient-purple { box-shadow: inset 0 0 60px rgba(142, 68, 173, 0.4) !important; border-color: #8e44ad !important; }
        #top-area { display: grid; grid-template-columns: 1fr auto 1fr auto 1fr; align-items: center; justify-items: center; width: 95%; padding-top: 10px; min-height: 140px; position: relative; z-index: 5; grid-row: 1; align-self: start; }
        .bot-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; width: 100px; position: relative; transition: 0.3s; }
        .bot-name { background: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 0.8em; z-index: 5; margin-bottom: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: 0.3s; white-space: nowrap; border: 1px solid #ddd; }
        .current-player .bot-name { background: #3498db; color: white; box-shadow: 0 0 10px #3498db; transform: scale(1.1); border-color: #2980b9; }
        .chat-bubble { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; border: 2px solid #333; padding: 5px 8px; border-radius: 8px; font-size: 0.7em; font-weight: bold; white-space: normal; width: 120px; text-align: center; box-shadow: 0 4px 10px rgba(0,0,0,0.4); z-index: 300; opacity: 0; pointer-events: none; line-height: 1.1; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s; }
        .chat-bubble.visible { opacity: 1; }
        .bot-stack-visual { position: relative; height: 90px; width: 100px; margin-top: 5px; transition: width 0.3s; display: flex; justify-content: center; }
        
        /* DESEN D√úZELTMESƒ∞: background-image deƒüil background ve !important kullanƒ±mƒ± */
        .mini-card-back { width: 60px; height: 90px; border: 3px solid #fff; border-radius: 8px; position: absolute; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); background-size: cover; background-position: center; box-sizing: border-box; display: flex; justify-content: center; align-items: center; overflow: hidden; transition: all 0.3s; background: var(--card-pattern) !important; }
        .card-back-style { background: var(--card-pattern) !important; background-size: cover; border: 3px solid #fff !important; }
        
        .mini-card-back::after, .card-back-style::after { content: "SON\A TABAK"; position: absolute; transform: rotate(-15deg); color: #3498db; font-family: 'Comic Sans MS', cursive; font-weight: 900; font-size: 1.1em; white-space: pre; text-align: center; line-height: 0.9; pointer-events: none; text-shadow: 2px 2px 0 #fff; }
        .mini-card-back::after { font-size: 0.75em; transform: rotate(-15deg) scale(0.8); }
        
        /* OKLAR */
        .arrow-icon { font-size: 2.5em; color: #bdc3c7; font-weight: 900; transition: all 0.5s; z-index: 10; position: absolute; top: 50%; transform: translateY(-50%); opacity: 1; }
        .arrow-icon.active { animation: pulseArrow 2s infinite; text-shadow: 0 0 20px currentColor; z-index: 20; }
        
        .arrow-top-static { position: static; margin: 0 15px; font-size: 2.5em; color: #bdc3c7; font-weight: 900; transition: all 0.3s; display: inline-block; transform-origin: center; transform: scale(1); }
        .arrow-top-static.active { animation: pulseArrowStatic 1.2s infinite ease-in-out; text-shadow: 0 0 20px currentColor; color: #3498db; }
        
        @keyframes pulseArrow { 0% { transform: translateY(-50%) scale(1.0); } 50% { transform: translateY(-50%) scale(1.25); } 100% { transform: translateY(-50%) scale(1.0); } }
        @keyframes pulseArrowStatic { 0% { transform: scale(1.0); } 50% { transform: scale(1.3); } 100% { transform: scale(1.0); } }
        
        .arrow-spin { animation: spinArrow 1.2s ease-in-out forwards !important; }
        @keyframes spinArrow { 0% { transform: translateY(-50%) rotate(0deg) scale(1); } 50% { transform: translateY(-50%) rotate(180deg) scale(1.4); color: #e74c3c; } 100% { transform: translateY(-50%) rotate(360deg) scale(1); } }
        
        .glow-red { color: #c0392b !important; } .glow-green { color: #27ae60 !important; } .glow-yellow { color: #f1c40f !important; } .glow-purple { color: #9b59b6 !important; } .glow-neutral { color: #3498db !important; }
        #arrow-left { left: 25px; } #arrow-right { right: 25px; } 
        
        #play-area { display: flex; align-items: center; justify-content: center; gap: 80px; width: 100%; min-height: 180px; position: relative; transition: transform 0.3s; z-index: 5; grid-row: 2; align-self: center; }
        .card { width: 105px; height: 155px; border-radius: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; font-weight: bold; cursor: pointer; border: 3px solid #555; box-shadow: 5px 5px 15px rgba(0,0,0,0.2); background-color: white; position: relative; user-select: none; transition: transform 0.2s; box-sizing: border-box; flex-shrink: 0; }
        #draw-pile.card:hover { transform: none; }
        .playable:hover { transform: translateY(-30px) scale(1.1); z-index: 100; }
        .playable { border-color: #333; } 
        .card-corner { position: absolute; font-size: 1.2em; margin: 5px; }
        .top-left { top: 2px; left: 2px; } .bottom-right { bottom: 2px; right: 2px; transform: rotate(180deg); }
        .card-emoji { font-size: 4.5em; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
        .card[data-val="+2"] .card-emoji { font-size: 2.2em !important; letter-spacing: -5px !important; line-height: 1; padding: 0; }
        .guvec-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; font-size: 0.45em; line-height: 1; }
        .red { background-color: #ffcdd2; color: #c0392b; border-color: #c0392b; } .green { background-color: #c8e6c9; color: #27ae60; border-color: #27ae60; } .yellow { background-color: #fff9c4; color: #f39c12; border-color: #f39c12; } .purple { background-color: #e1bee7; color: #8e44ad; border-color: #8e44ad; }
        .wild-bg { background: conic-gradient(from 45deg, #e74c3c, #f1c40f, #2ecc71, #9b59b6, #e74c3c); border: 3px solid #fff; color: #fff; }
        #penalty-badge { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 900; font-size: 1.2em; color: white; width: 40px; height: 40px; border-radius: 50%; border: 3px solid white; display: none; justify-content: center; align-items: center; z-index: 70; transition: all 0.3s; animation: pulseBadge 1s infinite; text-shadow: 1px 1px 0 rgba(0,0,0,0.5); }
        #penalty-badge.p-1 { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; } #penalty-badge.p-2 { background: #f1c40f; box-shadow: 0 0 10px #f1c40f; } #penalty-badge.p-3 { background: #e67e22; box-shadow: 0 0 15px #e67e22; } #penalty-badge.p-4 { background: #e74c3c; box-shadow: 0 0 20px #e74c3c; transform: scale(1.1); } 
        @keyframes pulseBadge { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.15); } 100% { transform: translate(-50%, -50%) scale(1); } }
        #draw-counter { display: none; }
        #bottom-area { width: 100%; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; margin-bottom: 10px; position: relative; z-index: 10; grid-row: 3; align-self: end; }
        #son-tabak-container { margin-bottom: 5px; z-index: 10; display:flex; gap:10px; }
        #son-tabak-btn, #challenge-btn { padding: 12px 30px; border: none; border-radius: 30px; font-size: 1.2em; font-weight: bold; cursor: pointer; color: white; box-shadow: 0 5px 0 rgba(0,0,0,0.2); transition: 0.2s; }
        #son-tabak-btn { background-color: #e67e22; } #challenge-btn { background-color: #f1c40f; color: #333; }
        #son-tabak-btn:disabled, #challenge-btn:disabled { background-color: #bdc3c7; box-shadow: none; cursor: not-allowed; opacity: 0.6; color:#fff; }
        #player-hand { display: flex; flex-wrap: wrap; justify-content: center; align-content: center; align-items: center; gap: 8px; width: 90%; padding: 10px; height: auto; min-height: 160px; border: 2px dashed rgba(0,0,0,0.1); border-radius: 25px; overflow: visible; transition: all 0.3s; }
        .current-player-area { border: 4px dashed #3498db !important; background: rgba(255, 255, 255, 0.4) !important; box-shadow: 0 0 20px rgba(52, 152, 219, 0.5); }
        .hand-normal .card { width: 105px; height: 155px; }
        .hand-packed .card { width: 80px; height: 120px; font-size: 0.8em; border-width: 2px; } .hand-packed .card-emoji { font-size: 2.5em; }
        .hand-super-packed .card { width: 60px; height: 90px; font-size: 0.6em; border-width: 2px; } .hand-super-packed .card-emoji { font-size: 1.8em; }
        .buttons-container { display: flex; flex-direction: column; gap: 8px; margin-top: auto; }
        .game-btn { padding: 12px 20px; border: none; border-radius: 10px; font-size: 1em; font-weight: bold; cursor: pointer; color: white; width: 100%; margin-bottom: 0; }
        .btn-red { background-color: #c0392b; } .btn-blue { background-color: #3498db; } .btn-dark { background-color: #34495e; } .btn-green { background-color: #27ae60; }
        
        /* GERƒ∞ ALINAN ANIMASYON (1.0s) -> JS'te ANIM_CONFIG.FLY_DURATION ile e≈üle≈ümeli */
        .flying-card { position: fixed; z-index: 3000; pointer-events: none; transition: all 1.0s ease-in-out; }
        .blocked-anim { position: absolute; font-size: 4em; color: #c0392b; z-index: 300; text-shadow: 0 0 20px #fff; animation: fadeUp 2s forwards; pointer-events: none; transform: translate(-50%, -50%); /* MERKEZLEME */ }
        @keyframes fadeUp { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 80% { opacity: 1; } 100% { opacity: 0; transform: translate(-50%, -100px); } }
        .mixer-container { position: absolute; top: 50%; left: 50%; width: 0; height: 0; z-index: 4000; pointer-events: none; }
        .mixer-card { position: absolute; width: 70px; height: 100px; border: 3px solid #fff; border-radius: 8px; background-size: cover; background-position: center; box-shadow: 0 0 10px rgba(0,0,0,0.5); transform-origin: center 250px; top: -300px; left: -35px; background: var(--card-pattern) !important; }
        .mixer-card::after { content: "SON\A TABAK"; position: absolute; transform: rotate(-15deg); color: #3498db; font-weight: 900; font-size: 0.75em; white-space: pre; text-align: center; line-height:0.9; top: 35%; left: 5px; font-family: 'Comic Sans MS', cursive; }
        .anim-temp-card { position: fixed; width: 70px; height: 100px; border: 3px solid #fff; border-radius: 8px; background-size: cover; background-position: center; z-index: 4000; box-shadow: 0 0 10px rgba(0,0,0,0.5); pointer-events: none; }
        .anim-temp-card::after { content: "SON\A TABAK"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-15deg); color: #3498db; font-weight: 900; font-size: 0.9em; white-space: pre; text-align: center; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 4000; }
        .modal-box { background: white; padding: 30px; border-radius: 20px; text-align: center; width: 80%; max-width: 320px; height: auto; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .input-field { padding: 10px; width: 80%; margin: 5px; border: 1px solid #ccc; border-radius: 5px; }
        .color-picker { display: flex; justify-content: center; gap: 15px; margin-top: 15px; flex-wrap: wrap; }
        .color-opt { width: 50px; height: 50px; border-radius: 50%; border: 4px solid #333; cursor: pointer; transition: 0.2s; flex-shrink: 0; }
        .bg-red { background: #e74c3c; } .bg-green { background: #2ecc71; } .bg-yellow { background: #f1c40f; } .bg-purple { background: #9b59b6; }
        .pattern-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px; }
        .pattern-opt { width: 50px; height: 70px; border: 2px solid #ccc; cursor: pointer; background-size: cover; position: relative; }
        .pattern-opt::after { content: "SON"; position: absolute; transform: rotate(-15deg) scale(0.5); color: #3498db; font-weight: 900; top: 35%; left: 5px; text-shadow: 1px 1px 0 white; }
        #son-tabak-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #e67e22; color: white; padding: 30px 60px; font-size: 2.5em; font-weight: bold; border-radius: 25px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border: 6px solid white; display: none; z-index: 6000; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); text-align: center; width: auto; max-width: 90%; }
        .popup-sub { font-size: 0.6em; display: block; margin-top: 10px; font-weight: normal; }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }
        #challenge-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 25px 50px; font-size: 2em; font-weight: bold; border-radius: 20px; box-shadow: 0 0 40px rgba(0,0,0,0.7); border: 5px solid white; display: none; z-index: 6000; animation: popIn 0.3s ease-out; text-align: center; width: auto; max-width: 90%; }
        .challenge-valid { background-color: #27ae60; } .challenge-invalid { background-color: #c0392b; }
        .challenge-sub { font-size: 0.6em; display: block; margin-top: 5px; font-weight: normal; opacity: 0.9; }
        
        #leave-modal .modal-box { border: 4px solid #c0392b; }
        #mixer-info { font-size: 0.85em; background: #ecf0f1; padding: 10px; border-radius: 8px; margin: 10px 0; text-align: left; }
        
        @media screen and (max-width: 900px) {
            body { height: 100%; overflow-y: auto; display: block; background: #2c3e50; }
            .main-wrapper { display: flex; flex-direction: column; height: auto; min-height: 100vh; padding: 5px; gap: 10px; }
            #brand-area { padding: 5px 10px; flex-direction: row; align-items: center; gap: 5px; order: 1; }
            .brand-title { font-size: 1.1em; display: flex; gap: 5px; } .version { font-size: 0.6em; margin: 0; align-self: center; } .brand-sub { font-size: 0.7em; margin: 0; margin-left: auto; }
            .game-container { display: grid; grid-template-rows: auto 1fr auto; order: 2; height: 60vh; min-height: 420px; align-items: center; justify-items: center; }
            #top-area { grid-row: 1; align-self: start; height: 90px; padding-top: 5px; width: 100%; justify-content: space-around; min-height: auto; grid-template-columns: 1fr auto 1fr auto 1fr; }
            #play-area { grid-row: 2; align-self: center; gap: 20px; height: 140px; transform: scale(0.8); margin-top: 0; }
            #bottom-area { grid-row: 3; align-self: end; }
            .bot-wrapper { transform: scale(0.7); margin: 0; } 
            .arrow-icon { font-size: 1.5em; position: absolute; top: 50%; transform: translateY(-50%); z-index: 15; }
            #arrow-left { left: 5px; } #arrow-right { right: 5px; } #arrow-top-1, #arrow-top-2 { font-size: 1.5em; margin: 0; }
            .flying-card { transform: scale(0.8); transform-origin: top left; }
            .card[data-val="+2"] .card-emoji { font-size: 2.5em !important; letter-spacing: -1px !important; }
            #player-hand { height: auto; min-height: 100px; padding: 8px; gap: 4px; border-width: 2px; justify-content: center; align-items: center; align-content: center; }
            .hand-normal .card, .hand-packed .card, .hand-super-packed .card { width: 45px; height: 70px; font-size: 0.5em; border-width: 1px; }
            .hand-normal .card-emoji, .hand-packed .card-emoji, .hand-super-packed .card-emoji { font-size: 1.8em; }
            .hand-normal .card[data-val="+2"] .card-emoji, .hand-packed .card[data-val="+2"] .card-emoji { font-size: 1.2em !important; letter-spacing: -2px !important; }
            #son-tabak-btn, #challenge-btn { padding: 8px 15px; font-size: 0.8em; margin-bottom: 5px; }
            #son-tabak-popup, #challenge-popup { position: fixed !important; }
            .right-panel { order: 3; height: auto; flex-direction: row; gap: 5px; flex-wrap: wrap; }
            .flip-container, .chat-container { height: 160px; flex: 1; min-width: 45%; }
            .buttons-container { width: 100%; flex-direction: row; gap: 5px; }
            .game-btn { font-size: 0.8em; padding: 8px; }
            #chat-messages { font-size: 0.75em !important; padding: 5px !important; gap: 2px !important; }
            .chat-line { line-height: 1.2 !important; margin-bottom: 3px !important; }
        }
    </style>
</head>
<body>
<canvas id="confetti-canvas"></canvas>

<!-- Gƒ∞Rƒ∞≈û EKRANI -->
<div id="login-overlay">
    <div class="lobby-box">
        <h2>üçΩÔ∏è Son Tabak Online</h2>
        <p>Oyuna katƒ±lmak i√ßin adƒ±nƒ± gir:</p>
        <input type="text" id="username-in" class="input-field" placeholder="Kullanƒ±cƒ± Adƒ±" maxlength="12">
        <br><br>
        <button class="game-btn btn-blue" id="login-btn">Giri≈ü Yap</button>
    </div>
</div>

<!-- LOBƒ∞ EKRANI -->
<div id="lobby-overlay" style="display:none;">
    <div class="lobby-box">
        <h3>üè† Odalar</h3>
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <input type="text" id="room-name-in" class="input-field" placeholder="Oda Adƒ±">
            <input type="password" id="room-pass-in" class="input-field" placeholder="≈ûifre (Opsiyonel)" style="width:100px;">
        </div>
        <button class="game-btn btn-green" id="create-room-btn">Oda Olu≈ütur</button>
        <hr>
        <div id="room-list" style="text-align:left; max-height:200px; overflow-y:auto;">
            <div style="text-align:center; color:#777;">Y√ºkleniyor...</div>
        </div>
    </div>
</div>

<!-- ODA BEKLEME EKRANI -->
<div id="waiting-room-overlay" class="modal">
    <div class="modal-box">
        <h3 id="wr-room-name">Oda: ...</h3>
        <p>Oyuncular bekleniyor (<span id="wr-count">0</span>/4)</p>
        <ul id="wr-player-list" class="player-list"></ul>
        <div id="wr-host-controls" style="display:none;">
            <p style="font-size:0.8em; color:#e67e22;">Eksik oyuncular yerine Bot (ü§ñ) eklenecek.</p>
            <button class="game-btn btn-blue" id="start-game-btn">Oyunu Ba≈ülat üöÄ</button>
        </div>
        <div id="wr-guest-controls">
            <p>Host'un ba≈ülatmasƒ± bekleniyor...</p>
        </div>
        <br>
        <button class="game-btn btn-red" id="leave-room-btn">√áƒ±kƒ±≈ü</button>
    </div>
</div>

<!-- √áIKI≈û ONAY MODALI -->
<div id="leave-modal" class="modal">
    <div class="modal-box">
        <h3>üö® Oyundan √áƒ±k?</h3>
        <p>Oyundan ayrƒ±lmak istediƒüine emin misin?</p>
        <br>
        <div style="display:flex; gap:10px; width:100%; justify-content:center;">
            <button class="game-btn btn-red" onclick="confirmLeaveGame()">Evet, √áƒ±k</button>
            <button class="game-btn btn-blue" onclick="document.getElementById('leave-modal').style.display='none'">ƒ∞ptal</button>
        </div>
    </div>
</div>

<div class="main-wrapper">
    <!-- LOGO -->
    <div id="brand-area">
        <div class="brand-title">üçΩÔ∏è Son Tabak <span class="version">v5.7 ANIM ‚ú®</span></div>
        <div class="brand-sub">üî•Kalority</div>
    </div>
    <!-- OYUN ALANI -->
    <div class="game-container">
        <!-- Oklar -->
        <div id="arrow-left" class="arrow-icon">‚¨ÜÔ∏è</div>
        <div id="arrow-right" class="arrow-icon">‚¨áÔ∏è</div>
        <div id="top-area">
            <div class="bot-wrapper" id="bot1-wrapper">
                <div class="bot-name" id="bot1-name">Oyuncu 2</div>
                <div class="bot-stack-visual" id="bot1-stack"></div>
                <div class="chat-bubble" id="bot1-chat"></div>
            </div>
            <div id="arrow-top-1" class="arrow-top-static">‚û°Ô∏è</div>
            <div class="bot-wrapper" id="bot2-wrapper">
                <div class="bot-name" id="bot2-name">Oyuncu 3</div>
                <div class="bot-stack-visual" id="bot2-stack"></div>
                <div class="chat-bubble" id="bot2-chat"></div>
            </div>
            <div id="arrow-top-2" class="arrow-top-static">‚û°Ô∏è</div>
            <div class="bot-wrapper" id="bot3-wrapper">
                <div class="bot-name" id="bot3-name">Oyuncu 4</div>
                <div class="bot-stack-visual" id="bot3-stack"></div>
                <div class="chat-bubble" id="bot3-chat"></div>
            </div>
        </div>
        <div id="play-area">
            <div id="draw-pile" class="card card-back-style" onclick="playerDrawCard()">
                <div id="draw-counter">+1</div>
                <div id="penalty-badge">+0</div> 
                <div id="deck-count" style="position:absolute; bottom:10px; color:white; font-size:1.5em; text-shadow:1px 1px 2px #000;">0</div>
            </div>
            <div id="discard-pile"></div>
            <div id="son-tabak-popup">SON TABAK!<span id="son-tabak-who" class="popup-sub"></span></div>
            <div id="challenge-popup"><span id="challenge-who"></span><span id="challenge-result" class="challenge-sub"></span></div>
        </div>
        <div id="bottom-area">
            <div id="son-tabak-container">
                <button id="son-tabak-btn" onclick="playerSaySonTabak()">SON TABAK!</button>
                <button id="challenge-btn" onclick="challengePreviousPlayer()" disabled>‚úã ƒ∞Tƒ∞RAZ ET!</button>
            </div>
            <div id="player-hand" class="hand-normal"></div>
        </div>
    </div>
    <!-- SAƒû PANEL -->
    <div class="right-panel">
        <div class="flip-container" onclick="toggleInfoView(this)">
            <div class="flip-inner">
                <div class="flip-front">
                    <div class="panel-header"><span>üèÜ Puan</span><span class="panel-hint">üñ±Ô∏è Log</span></div>
                    <table id="score-table"><tbody></tbody></table>
                </div>
                <div class="flip-back">
                    <div class="panel-header" style="background:#7f8c8d;"><span>üìù Log</span><span class="panel-hint">üñ±Ô∏è Puan</span></div>
                    <ul id="system-log"></ul>
                </div>
            </div>
        </div>
        <div class="chat-container">
            <div id="chat-messages"></div>
            <div class="chat-input-area">
                <input type="text" id="player-input" placeholder="Yaz..." onkeypress="handleChatKey(event)">
                <button id="send-btn" onclick="playerSendMessage()">‚û§</button>
            </div>
        </div>
        <div class="buttons-container">
            <button class="game-btn btn-green" onclick="openRules()">Nasƒ±l Oynanƒ±r?</button>
            <button class="game-btn btn-blue" onclick="openPatternModal()">Kart Deseni</button>
            <button class="game-btn btn-red" onclick="leaveGame()">Oyundan √áƒ±k</button>
        </div>
    </div>
</div>

<div id="rules-modal" class="modal">
    <div class="modal-box" style="text-align:left; max-height:80vh; overflow-y:auto;">
        <h3>üìñ Nasƒ±l Oynanƒ±r?</h3>
        <p style="font-size:0.9em;">
            1. Ama√ß elindeki kartlarƒ± bitirmektir.<br>
            2. Yerdeki kart ile aynƒ± renk veya aynƒ± sayƒ±/sembol atabilirsin.<br>
            3. √ñzel kartlar (Mikser, Sofra, G√ºve√ß) rengi deƒüi≈ütirir veya oyunun akƒ±≈üƒ±nƒ± bozar.<br>
            4. Elinde 2 kart varken hamle yapƒ±p 1 karta d√º≈üeceƒüin zaman "SON TABAK" demeyi unutma!<br>
            5. Unutanlara "ƒ∞Tƒ∞RAZ ET" butonu ile ceza verebilirsin.<br>
            6. Bol ≈üans! üçÖü•¶
        </p>
        <button class="game-btn btn-blue" onclick="document.getElementById('rules-modal').style.display='none'">Anladƒ±m</button>
    </div>
</div>

<div id="pattern-modal" class="modal">
    <div class="modal-box">
        <h3>Kart Deseni</h3>
        <div class="pattern-grid" id="pattern-grid"></div>
        <br><button class="game-btn btn-blue" onclick="closePatternModal()">Kapat</button>
    </div>
</div>

<div id="color-modal" class="modal">
    <div class="modal-box">
        <h3>Renk Se√ß</h3>
        <div class="color-picker">
            <div class="color-opt bg-red" onclick="resolveColor('red')"></div>
            <div class="color-opt bg-green" onclick="resolveColor('green')"></div>
            <div class="color-opt bg-yellow" onclick="resolveColor('yellow')"></div>
            <div class="color-opt bg-purple" onclick="resolveColor('purple')"></div>
        </div>
    </div>
</div>

<div id="dir-modal" class="modal">
    <div class="modal-box">
        <h3>Y√∂n Se√ß (Mikser)</h3>
        <p id="dir-text" style="font-size:0.8em; margin:5px 0;">Eller hangi y√∂ne kaysƒ±n?</p>
        <div id="mixer-info"></div>
        <div class="color-picker">
            <button class="game-btn btn-blue" onclick="resolveDirection(1)">‚û°Ô∏è Saat</button>
            <button class="game-btn btn-blue" onclick="resolveDirection(-1)">‚¨ÖÔ∏è Ters</button>
        </div>
    </div>
</div>

<div id="end-modal" class="modal">
    <div class="modal-box" style="max-width: 400px;">
        <h2 id="winner-text"></h2>
        <div id="ai-summary" style="font-style:italic; font-size:0.9em; margin:15px 0; color:#555; border-top:1px solid #eee; border-bottom:1px solid #eee; padding:10px;"></div>
        <div id="final-scores"></div>
        <br>
        <div style="display:flex; gap:15px; width:100%;">
            <button id="end-continue-btn" class="game-btn btn-blue" style="flex:1;" onclick="toggleReadyState()">Devam Et ‚è≥</button>
            <button id="host-start-btn" class="game-btn btn-green" style="flex:1; display:none;" onclick="nextRound()">YENƒ∞ EL BA≈ûLAT</button>
            <button class="game-btn btn-red" style="flex:1;" onclick="leaveGame()">√áƒ±kƒ±≈ü</button>
        </div>
    </div>
</div>

<div id="toast" style="position:fixed; top:20px; left:50%; transform:translateX(-50%); background:#333; color:#fff; padding:10px 20px; border-radius:20px; display:none; z-index:5000;"></div>

<script>
/* --- ANIMATION & CONFIG CONSTANTS --- */
const ANIM_CONFIG = {
    FLY_DURATION: 1000,      
    FLY_BUFFER: 1100,        
    DRAW_INTERVAL: 600,      
    INITIAL_DEAL: 250,       
    TOAST: 2000,             
    POPUP: 3000,             
    BOT_THINK: 300,          
    HEARTBEAT_MS: 5000,      
    HOST_TIMEOUT: 15000,     
    AFK_TIMEOUT: 60000,      
    BOT_WATCHDOG: 3000       
};

/* --- CARD NAMES MAPPING --- */
const CARD_NAMES = {
    '+1': 'üì¶ +1',
    '+2': 'üì¶üì¶ +2',
    'Reverse': '‚ôªÔ∏è Geri D√∂n√º≈ü√ºm',
    'Block': 'üî™ Bƒ±√ßak',
    'Wild': 'G√ºve√ß',
    'Wild Anti-Draw': 'üßª Tuvalet Kaƒüƒ±dƒ±',
    'Wild Pot': 'üç≤ D√ºd√ºkl√º Tencere',
    'Wild Table': 'üçΩÔ∏è Sofra',
    'Wild Mixer': 'üå™Ô∏è Mikser',
    'Wild Meze': 'üç± Meze'
};

/* --- PATTERNS --- */
const CARD_PATTERNS = [
    'linear-gradient(135deg, #e67e22 0%, #d35400 100%)', // Default Orange
    'repeating-linear-gradient(45deg, #e67e22, #e67e22 10px, #d35400 10px, #d35400 20px)',
    'radial-gradient(circle, #e67e22 20%, #d35400 90%)',
    'conic-gradient(#e67e22, #d35400, #e67e22)',
    'linear-gradient(135deg, #3498db 0%, #2980b9 100%)', // Blue
    'linear-gradient(135deg, #34495e 0%, #2c3e50 100%)', // Dark 1
    'repeating-linear-gradient(45deg, #34495e, #34495e 10px, #2c3e50 10px, #2c3e50 20px)',
    'radial-gradient(circle, #7f8c8d 20%, #2c3e50 90%)'
];
let currentPattern = CARD_PATTERNS[0];

/* --- FIREBASE INIT --- */
const firebaseConfig = {
  apiKey: "AIzaSyDqyHqluehXJHt4xeanl51LRVG4AeQ3Ijk",
  authDomain: "son-tabak.firebaseapp.com",
  databaseURL: "https://son-tabak-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "son-tabak",
  storageBucket: "son-tabak.firebasestorage.app",
  messagingSenderId: "994436192152",
  appId: "1:994436192152:web:35d17d0dbb1d5d0015fded"
};

let app, db, auth;
try {
    app = firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    auth = firebase.auth();
    console.log("Firebase Init OK");
} catch(e) {
    alert("Firebase Hatasƒ±: " + e.message);
}

/* --- SES VE CHAT --- */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

const SoundFX = {
    playTone: (freq, type, duration, rampTo = 0.001) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(rampTo, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    },
    playCardSnap: () => SoundFX.playTone(800, 'sine', 0.1),
    playDraw: () => SoundFX.playTone(400, 'triangle', 0.15),
    playBlock: () => { SoundFX.playTone(1500, 'sawtooth', 0.1); setTimeout(() => SoundFX.playTone(2000, 'sine', 0.3), 50); },
    playReverse: () => { if(audioCtx.state === 'suspended') audioCtx.resume(); const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.3); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3); osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.3); },
    playWild: () => { [300, 400, 500, 600, 800].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'sine', 0.2), i*50)); },
    playBad: () => { SoundFX.playTone(150, 'sawtooth', 0.2); setTimeout(() => SoundFX.playTone(120, 'sawtooth', 0.4), 100); },
    playError: () => { SoundFX.playTone(100, 'square', 0.2); },
    playFanfare: () => { [523, 659, 783, 1046].forEach((f, i) => setTimeout(() => SoundFX.playTone(f, 'square', 0.4), i * 150)); },
    playUno: () => SoundFX.playTone(1200, 'sine', 0.5)
};

const CHAT_POOL = {
    "Agresif": { "start_good": ["Daƒüƒ±lƒ±n!", "Acƒ±mam."], "block": ["Ge√ß!", "Bekle!"], "plus2": ["Al bakalƒ±m!", "+2 cnm"], "wild": ["Ben ne dersem o!"], "draw_many": ["D√ºkkanƒ± aldƒ±m!", "Bu ne?!"], "win": ["Ezdim!", "Kral benim!"], "fail": ["Olamaz!", "Hile!"] },
    "Stratejik": { "start_good": ["Plan hazƒ±r."], "block": ["Sƒ±radaki."], "plus2": ["Stratejik hamle."], "wild": ["Renk deƒüi≈üimi."], "draw_many": ["Plan deƒüi≈üti."], "win": ["Matematik kazandƒ±."], "fail": ["Hesap hatasƒ±."] },
    "Panik Atak": { "start_good": ["Heyecanlƒ±yƒ±m!"], "block": ["Pardon!", "√ñz√ºr!"], "plus2": ["Kƒ±zma n'olur!"], "wild": ["Ay ne se√ßsem?"], "draw_many": ["Boƒüuluyorum!", "ƒ∞mdat!"], "win": ["Ben mi kazandƒ±m?"], "fail": ["G√∂rmedim!"] },
    "Rahat": { "start_good": ["Akarƒ± var."], "block": ["Soluklan.", "Yava≈ü."], "plus2": ["Hediye.", "Yorma kendini."], "wild": ["Deƒüi≈üiklik iyidir."], "draw_many": ["Ooo bana girdi.", "Nasip."], "win": ["Tertemiz.", "Kolaydƒ±."], "fail": ["Dalmƒ±≈üƒ±m."] },
    "Gƒ±cƒ±k": { "start_good": ["Ezikler."], "block": ["Kudur!", "Zaa!"], "plus2": ["Beter ol.", "Aƒülama."], "wild": ["Biat edin!"], "draw_many": ["Hile var!", "Of ya."], "win": ["√áok kolaysƒ±nƒ±z."], "fail": ["√ñnemli deƒüil."] },
    "Dengeli": { "start_good": ["Ba≈ülayalƒ±m."], "block": ["Ge√ß bakalƒ±m."], "plus2": ["+2 √ßek."], "wild": ["Renk deƒüi≈üsin."], "draw_many": ["Bayaƒüƒ± √ßektim."], "win": ["G√ºzel oyun."], "fail": ["T√ºh."] }
};

let myUid = null; let myName = ""; let currentRoomId = null; let isHost = false;
let roomUnsubscribe = null; let myPlayerIdx = -1;
let localPlayers = []; let lastGameState = null; let lastChatTs = 0; let amIReady = false; let heartbeatInterval = null;
let actionQueue = []; let isProcessingQueue = false;
let localSaidSonTabak = false; 
let isDealing = false;

/* --- LOGIC --- */
auth.onAuthStateChanged((user) => { if (user) myUid = user.uid; });

document.getElementById('login-btn').addEventListener('click', () => {
    const name = document.getElementById('username-in').value.trim();
    if(!name) return alert("L√ºtfen bir isim gir!");
    document.getElementById('login-btn').innerText = "Giri≈ü Yapƒ±lƒ±yor...";
    
    auth.signInAnonymously()
        .then(() => {
            myName = name;
            if(audioCtx.state === 'suspended') audioCtx.resume();
            document.getElementById('login-overlay').style.display = 'none';
            document.getElementById('lobby-overlay').style.display = 'flex';
            listenRooms();
        })
        .catch((e) => {
            alert("Giri≈ü Hatasƒ±: " + e.message);
            document.getElementById('login-btn').innerText = "Giri≈ü Yap";
        });
});

function listenRooms() {
    const list = document.getElementById('room-list');
    db.collection("rooms").onSnapshot((snapshot) => {
        list.innerHTML = "";
        if(snapshot.empty) list.innerHTML = "<div style='text-align:center;color:#777;'>Oda yok. ƒ∞lk odayƒ± sen kur!</div>";
        const now = Date.now();
        snapshot.forEach(docSnap => {
            const r = docSnap.data();
            if (r.lastActive && now - r.lastActive > 60000) { docSnap.ref.delete().catch(() => {}); return; }
            if(r.status === 'finished') return; 
            
            // Sadece ger√ßek insan sayƒ±sƒ±nƒ± g√∂ster
            let realHumans = r.players.filter(p => !p.isBot).length;
            let statusText = r.status === 'playing' ? 'üî¥ Oynanƒ±yor' : 'üü¢ Bekliyor';
            let botCount = r.players.filter(p => p.isBot).length;
            let joinText = "Katƒ±l";
            
            if (r.status === 'playing') {
                if (botCount > 0) joinText = "Oyuna Gir üöÄ";
                else joinText = "Dolu üîí"; 
            }

            const div = document.createElement('div');
            div.className = 'room-item';
            // D√úZELTME: ƒ∞nsan Sayƒ±sƒ± / 4
            div.innerHTML = `<span><b>${r.name}</b> (${realHumans}/4) ${statusText}</span>`;
            
            if (r.status !== 'playing' || botCount > 0) {
                const joinBtn = document.createElement('button');
                joinBtn.className = 'game-btn btn-blue'; joinBtn.style.padding = '5px 10px'; joinBtn.innerText = joinText;
                joinBtn.onclick = () => joinRoom(docSnap.id, r.hasPassword);
                div.appendChild(joinBtn);
            }
            list.appendChild(div);
        });
    });
}

document.getElementById('create-room-btn').addEventListener('click', () => {
    const rName = document.getElementById('room-name-in').value.trim() || `${myName}'in Odasƒ±`;
    const rPass = document.getElementById('room-pass-in').value.trim();
    db.collection("rooms").add({
        name: rName, password: rPass, hasPassword: !!rPass, hostId: myUid, status: 'waiting', lastActive: Date.now(),
        players: [{ uid: myUid, name: myName, isBot: false, score: 0, hand: [], isReady: false, saidSonTabak: false, challengeUsed: false, personality: 'Dengeli', lastSeen: Date.now() }],
        gameState: null
    }).then(ref => {
        currentRoomId = ref.id; isHost = true; enterWaitingRoom();
    });
});

function joinRoom(roomId, hasPass) {
    if(hasPass) {
        const p = prompt("Oda ≈ûifresi:"); if(p === null) return;
        db.collection("rooms").doc(roomId).get().then(doc => {
             if(doc.data().password !== p) return alert("Yanlƒ±≈ü ≈ûifre!");
             proceedJoin(roomId);
        });
    } else proceedJoin(roomId);
}

function proceedJoin(roomId) {
    const roomRef = db.collection("rooms").doc(roomId);
    roomRef.get().then(doc => {
        if(!doc.exists) return alert("Oda yok!");
        const rData = doc.data();
        let players = rData.players;
        
        if(players.length >= 4 && !players.some(p => p.isBot)) return alert("Oda tamamen dolu!");
        
        let targetIndex = -1;
        const sameNameBotIdx = players.findIndex(p => p.isBot && p.name.includes(myName));
        if (sameNameBotIdx !== -1) {
            targetIndex = sameNameBotIdx;
        } else {
            const botIdx = players.findIndex(p => p.isBot);
            if (botIdx !== -1) targetIndex = botIdx;
        }

        if (targetIndex !== -1) {
            players[targetIndex] = {
                ...players[targetIndex],
                uid: myUid,
                name: myName,
                isBot: false,
                isReady: rData.status === 'playing', 
                lastSeen: Date.now()
            };
            roomRef.update({ players: players }).then(() => {
                currentRoomId = roomId; isHost = false; enterWaitingRoom();
            });
        } else {
            if(rData.status === 'playing') return alert("Oda dolu ve bot yok!");
            roomRef.update({
                players: firebase.firestore.FieldValue.arrayUnion({ uid: myUid, name: myName, isBot: false, score: 0, hand: [], isReady: false, saidSonTabak: false, challengeUsed: false, personality: 'Dengeli', lastSeen: Date.now() })
            }).then(() => {
                currentRoomId = roomId; isHost = false; enterWaitingRoom();
            });
        }
    });
}

function enterWaitingRoom() {
    document.getElementById('lobby-overlay').style.display = 'none';
    document.getElementById('waiting-room-overlay').style.display = 'flex';
    if(roomUnsubscribe) roomUnsubscribe();
    
    if(heartbeatInterval) clearInterval(heartbeatInterval);
    heartbeatInterval = setInterval(sendHeartbeat, ANIM_CONFIG.HEARTBEAT_MS);

    roomUnsubscribe = db.collection("rooms").doc(currentRoomId).onSnapshot((docSnap) => {
        if(!docSnap.exists) { location.reload(); return; }
        const data = docSnap.data();
        localPlayers = data.players;
        
        const firstHuman = localPlayers.find(p => !p.isBot);
        isHost = (firstHuman && firstHuman.uid === myUid);

        const humanPlayers = localPlayers.filter(p => !p.isBot);
        if (humanPlayers.length >= 2 && humanPlayers[1].uid === myUid) {
            const currentHost = humanPlayers[0]; 
            if (currentHost.lastSeen && (Date.now() - currentHost.lastSeen > ANIM_CONFIG.HOST_TIMEOUT)) {
                const updatedPlayers = localPlayers.map(p => {
                    if (p.uid === currentHost.uid) {
                        return { ...p, uid: 'replaced_host_' + Date.now(), name: 'ü§ñ ' + p.name, isBot: true, isReady: true, personality: 'Agresif', lastSeen: Date.now() };
                    }
                    return p;
                });
                db.collection("rooms").doc(currentRoomId).update({ players: updatedPlayers }).then(() => showToast("Host d√º≈üt√º, yerine bot ge√ßti!"));
            }
        }

        document.getElementById(isHost ? 'wr-host-controls' : 'wr-guest-controls').style.display = 'block';
        document.getElementById(!isHost ? 'wr-host-controls' : 'wr-guest-controls').style.display = 'none';
        document.getElementById('wr-room-name').innerText = `Oda: ${data.name}`;
        document.getElementById('wr-count').innerText = localPlayers.length;
        const ul = document.getElementById('wr-player-list'); ul.innerHTML = "";
        localPlayers.forEach(p => { ul.innerHTML += `<li class="player-item"><span>${p.isBot?'ü§ñ ':''}${p.name}</span> ${(p.uid===firstHuman?.uid)?'(Host)':''}</li>`; });
        
        if(data.status === 'playing') {
            document.getElementById('waiting-room-overlay').style.display = 'none';
            myPlayerIdx = localPlayers.findIndex(p => p.uid === myUid);
            syncGameLoop(data);
        }
    });
}

function sendHeartbeat() {
    if(!currentRoomId || !myUid) return;
    db.collection("rooms").doc(currentRoomId).get().then(doc => {
        if(doc.exists) {
            let ps = doc.data().players;
            let me = ps.find(p => p.uid === myUid);
            if(me) {
                me.lastSeen = Date.now();
                db.collection("rooms").doc(currentRoomId).update({ players: ps, lastActive: Date.now() });
            }
        }
    });
}

document.getElementById('start-game-btn').addEventListener('click', () => {
    if(localPlayers.length < 2) return alert("En az 2 oyuncu!");
    let finalPlayers = [...localPlayers];
    const botNames = ["ü§ñ Rifu", "ü§ñ Utku", "ü§ñ K√ºbra", "ü§ñ Atlas"];
    const personalities = ["Agresif", "Stratejik", "Panik Atak", "Rahat", "Gƒ±cƒ±k"];
    let botIdx = 0;
    while(finalPlayers.length < 4) {
        let pType = personalities[Math.floor(Math.random()*personalities.length)];
        finalPlayers.push({ uid: 'bot_' + Date.now() + '_' + botIdx, name: botNames[botIdx % botNames.length], isBot: true, score: 0, hand: [], isReady: true, saidSonTabak: false, challengeUsed: false, personality: pType, lastSeen: Date.now() });
        botIdx++;
    }
    finalPlayers = shuffleDeck(finalPlayers);
    finalPlayers = finalPlayers.map(p => ({...p, isReady: false, saidSonTabak: false, challengeUsed: false }));
    
    const newDeck = createFullDeck();
    const hands = [[], [], [], []];
    for(let i=0; i<7; i++) { for(let p=0; p<4; p++) hands[p].push(newDeck.pop()); }
    finalPlayers.forEach((p, i) => p.hand = hands[i]);
    let first = newDeck.pop();
    while(first.color === 'wild' || first.type === 'action') { newDeck.unshift(first); first = newDeck.pop(); }
    
    const initialState = {
        deck: newDeck, discardPile: [first], currentPlayer: Math.floor(Math.random()*4), direction: 1, drawStack: 0, gameActive: true,
        lastAction: { type: 'start', timestamp: Date.now() }, vulnerablePlayerIdx: -1, playerColors: shuffleDeck(['#c0392b', '#f1c40f', '#8e44ad', '#27ae60']),
        lastChat: { sender: "Sistem", msg: "Oyun Ba≈üladƒ±!", ts: Date.now(), isSystem: true }, hasDrawn: false
    };
    db.collection("rooms").doc(currentRoomId).update({ status: 'playing', players: finalPlayers, gameState: initialState, lastActive: Date.now() });
});

/* --- GAME LOOP (Sync Logic) --- */
let isBotThinking = false; 
let lastBotActionTime = 0; 

function syncGameLoop(roomData) {
    const gs = roomData.gameState;
    if(!gs) return;
    
    gameDeck = gs.deck; gameDiscard = gs.discardPile; gamePlayers = roomData.players;
    gameHands = gamePlayers.map(p => p.hand);
    currentPlayer = gs.currentPlayer; direction = gs.direction; drawStack = gs.drawStack;
    gameActive = gs.gameActive; vulnerablePlayerIdx = gs.vulnerablePlayerIdx; playerColors = gs.playerColors;
    hasDrawn = gs.hasDrawn || false;

    if(currentPlayer !== myPlayerIdx) localSaidSonTabak = false;

    if(gs.lastChat && gs.lastChat.ts > lastChatTs) {
        if(gs.lastChat.isSystem) addSystemLog(gs.lastChat.msg);
        else {
            let senderIdx = gamePlayers.findIndex(p => p.name === gs.lastChat.sender);
            let color = senderIdx !== -1 ? (playerColors[senderIdx] || '#333') : '#333';
            addChatLog(gs.lastChat.sender, gs.lastChat.msg, color);
            if(senderIdx !== -1 && senderIdx !== myPlayerIdx) {
                let relIdx = (senderIdx - myPlayerIdx + 4) % 4; 
                let b = document.getElementById(`bot${relIdx}-chat`);
                if(b) { b.innerText = gs.lastChat.msg; b.classList.add('visible'); setTimeout(()=>b.classList.remove('visible'),3000); }
            }
        }
        lastChatTs = gs.lastChat.ts;
    }

    if(lastGameState && lastGameState.lastAction.timestamp !== gs.lastAction.timestamp) {
        actionQueue.push(gs.lastAction);
        processActionQueue();
    } else if (!isProcessingQueue) {
        updateUI(); 
    }
    
    if(isHost && gameActive && !isBotThinking) {
        let currentPObj = gamePlayers[currentPlayer];
        if(!currentPObj.isBot) {
            let timeSinceAction = Date.now() - gs.lastAction.timestamp;
            if(timeSinceAction > ANIM_CONFIG.AFK_TIMEOUT) {
                const updatedPlayers = gamePlayers.map(p => {
                    if (p.uid === currentPObj.uid) {
                        return { ...p, uid: 'afk_bot_' + Date.now(), name: 'ü§ñ ' + p.name, isBot: true, isReady: true, personality: 'Dengeli', lastSeen: Date.now() };
                    }
                    return p;
                });
                db.collection("rooms").doc(currentRoomId).update({ 
                    players: updatedPlayers,
                    "gameState.lastChat": { sender: "Sistem", msg: `${currentPObj.name} AFK kaldƒ±ƒüƒ± i√ßin bot devraldƒ±.`, ts: Date.now(), isSystem: true }
                });
            }
        }
    }

    if(isBotThinking && Date.now() - lastBotActionTime > ANIM_CONFIG.BOT_WATCHDOG) {
        console.warn("Bot takƒ±ldƒ±! Sƒ±fƒ±rlanƒ±yor...");
        isBotThinking = false;
    }

    if (gs.winnerIdx !== undefined && gs.winnerIdx !== -1 && gameActive === false) {
        if(document.getElementById('end-modal').style.display !== 'flex') showEndGame(gs.winnerIdx, roomData.players);
        updateReadyStatusUI();
    }
    
    if(!lastGameState && gs.lastAction.type === 'start') {
         actionQueue.push(gs.lastAction); 
         processActionQueue();
    }
    
    lastGameState = gs;

    if(isHost && gameActive && !isProcessingQueue && actionQueue.length === 0 && !isBotThinking) {
        const currentPObj = gamePlayers[currentPlayer];
        if(currentPObj && currentPObj.isBot) {
            isBotThinking = true;
            lastBotActionTime = Date.now(); 
            setTimeout(() => {
                hostBotTurn().then(() => { isBotThinking = false; }).catch(e => { console.error("Bot Error", e); isBotThinking = false; });
            }, ANIM_CONFIG.BOT_THINK);
        }
    }
}

/* --- ACTION HANDLING --- */
async function processActionQueue() {
    if(isProcessingQueue || actionQueue.length === 0) return;
    isProcessingQueue = true;
    const action = actionQueue.shift();
    await handleRemoteAction(action); 
    updateUI();
    isProcessingQueue = false;
    processActionQueue();
}

async function handleRemoteAction(action) {
    if(!action) return;
    
    if(action.type === 'sonTabak') {
        const pName = gamePlayers[action.pIdx].name;
        showSonTabakPopup(pName);
        SoundFX.playUno();
    }
    else if(action.type === 'challenge') {
        let victimName = action.victimIdx !== undefined ? gamePlayers[action.victimIdx].name : "Biri";
        let msg = action.success ? "BA≈ûARILI! ‚úÖ" : "BA≈ûARISIZ! ‚ùå";
        let detail = action.success ? `${victimName} ceza yedi!` : `ƒ∞tiraz haksƒ±zdƒ±!`;
        showChallengePopup(action.success, msg, detail);
        
        if(action.success) SoundFX.playFanfare(); else SoundFX.playBad();
        
        if(action.victimIdx !== undefined) {
            await wait(500); 
            let targetId = action.victimIdx === myPlayerIdx ? 'player-hand' : `bot${(action.victimIdx - myPlayerIdx + 4) % 4}-wrapper`;
            animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null);
        }
    }
    else if(action.type === 'newRound' || action.type === 'start') {
        document.getElementById('end-modal').style.display = 'none';
        amIReady = false; 
        document.getElementById('end-continue-btn').innerText = "Devam Et ‚è≥";
        document.getElementById('end-continue-btn').className = "game-btn btn-blue";
        await animateInitialDeal();
    }
    else if(action.type === 'play') {
        let pIdx = action.pIdx;
        let sourceId = pIdx === myPlayerIdx ? 'player-hand' : pIdx === (myPlayerIdx+1)%4 ? 'bot1-wrapper' : pIdx === (myPlayerIdx+2)%4 ? 'bot2-wrapper' : 'bot3-wrapper';
        let source = document.getElementById(sourceId);
        if(pIdx === myPlayerIdx && source.children.length > 0) source = source.children[Math.min(source.children.length-1, 3)];
        
        await new Promise(r => animateFly(source, document.getElementById('discard-pile'), createCardHTML(action.card), r));
        
        document.getElementById('discard-pile').innerHTML = createCardHTML(action.card);
        if(action.card.val === 'Block') { SoundFX.playBlock(); animateBlock(pIdx); }
        else if(action.card.val === 'Reverse') { SoundFX.playReverse(); await animateReverse(); } 
        else if(action.card.color === 'wild') SoundFX.playWild();
        else SoundFX.playCardSnap();

        if(action.card.val === 'Wild Table') await animateTableEffect();
        if(action.card.val === 'Wild Mixer') await animateMixerEffect(direction); // FIX: Send correct direction
        if(action.card.val === 'Wild Pot') animatePotEffect(pIdx, direction);
        if(action.card.val === 'Wild Meze') animateMezeEffect(pIdx);
    } 
    else if(action.type === 'draw') {
        SoundFX.playDraw();
        let targetId = action.pIdx === myPlayerIdx ? 'player-hand' : `bot${(action.pIdx - myPlayerIdx + 4) % 4}-wrapper`;
        for(let k=0; k<action.count; k++) { await wait(ANIM_CONFIG.DRAW_INTERVAL); animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null); }
    }
    await wait(200);
}

/* --- GAME LOGIC (Host/Player) --- */
let gameDeck = [], gameDiscard = [], gameHands = [], gamePlayers = [], gameActive = false, direction = 1, currentPlayer = 0, drawStack = 0, vulnerablePlayerIdx = -1, playerColors = [], pendingWild = null, hasDrawn = false, lastWinner = -1;

function canPlay(card) {
    let top = gameDiscard[gameDiscard.length-1]; let topColor = top.chosenColor || top.color;
    if(drawStack > 0) { if(card.val === '+2' || card.val === 'Wild Meze' || card.val === 'Wild Anti-Draw') return true; if(card.val === '+1') { return top.val === '+2' || top.val === 'Wild Meze' ? card.color === topColor : true; } return false; }
    return card.color === 'wild' || card.color === topColor || card.val === top.val;
}

function playerDrawCard() {
    if(currentPlayer !== myPlayerIdx) return;
    if(drawStack === 0 && gameHands[myPlayerIdx].some(c => canPlay(c))) { showToast("Oynanacak kartƒ±n var!"); return; }
    if(hasDrawn) { serverPassTurn(myPlayerIdx); return; }
    
    let count = drawStack > 0 ? drawStack : 1;
    let isPenalty = drawStack > 0;
    
    serverDrawCard(myPlayerIdx, count, isPenalty);
    if(isPenalty || count > 1) { 
        setTimeout(() => serverPassTurn(myPlayerIdx), 1000); 
    }
}
function playerPlayCard(idx) {
    if(currentPlayer !== myPlayerIdx) return;
    let card = gameHands[myPlayerIdx][idx];
    if(canPlay(card)) {
        if(card.color === 'wild') {
            if(card.val === 'Wild Anti-Draw') { let top = gameDiscard[gameDiscard.length-1]; card.chosenColor = top.chosenColor || top.color; if(card.chosenColor==='wild') card.chosenColor = 'red'; serverPlayCard(myPlayerIdx, idx, card, 1, localSaidSonTabak); }
            else { pendingWild = { idx, card }; document.getElementById('color-modal').style.display = 'flex'; }
        } else serverPlayCard(myPlayerIdx, idx, card, 1, localSaidSonTabak);
    } else { SoundFX.playError(); showToast("Oynanamaz!"); }
}
function resolveColor(c) { 
    document.getElementById('color-modal').style.display = 'none'; 
    if(pendingWild) { 
        let card = pendingWild.card; card.chosenColor = c; 
        if(card.val === 'Wild Mixer') { 
            let pRightIdx = (myPlayerIdx + 1) % 4; // Saat y√∂n√ºndeki
            let pLeftIdx = (myPlayerIdx + 3) % 4; // Ters y√∂n√ºndeki
            let pRightName = gamePlayers[pRightIdx].name;
            let pLeftName = gamePlayers[pLeftIdx].name;
            let pRightCount = gameHands[pRightIdx].length;
            let pLeftCount = gameHands[pLeftIdx].length;

            document.getElementById('mixer-info').innerHTML = `
                <b>‚û°Ô∏è Saat:</b> ${pLeftName}'in elini (${pLeftCount} Kart) alacaksƒ±n.<br>
                <b>‚¨ÖÔ∏è Ters:</b> ${pRightName}'in elini (${pRightCount} Kart) alacaksƒ±n.
            `;
            document.getElementById('dir-modal').style.display = 'flex'; 
        } else { 
            serverPlayCard(myPlayerIdx, pendingWild.idx, card, 1, localSaidSonTabak); 
            pendingWild = null; 
        } 
    } 
}
function resolveDirection(d) { document.getElementById('dir-modal').style.display = 'none'; if(pendingWild) { serverPlayCard(myPlayerIdx, pendingWild.idx, pendingWild.card, d, localSaidSonTabak); pendingWild = null; } }

function playerSaySonTabak() { 
    if(currentPlayer !== myPlayerIdx || gameHands[myPlayerIdx].length > 2) return; 
    
    localSaidSonTabak = true; 
    
    let ps = [...gamePlayers]; ps[myPlayerIdx].saidSonTabak = true; 
    
    db.collection("rooms").doc(currentRoomId).update({ 
        players: ps, 
        "gameState.vulnerablePlayerIdx": -1, 
        "gameState.lastAction": { type: 'sonTabak', pIdx: myPlayerIdx, timestamp: Date.now() },
        "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[myPlayerIdx]}">${myName}</b> SON TABAK dedi!`, ts: Date.now(), isSystem: true } 
    }); 
}

function challengePreviousPlayer() {
    if(currentPlayer !== myPlayerIdx || gamePlayers[myPlayerIdx].challengeUsed) return;
    if(vulnerablePlayerIdx !== -1) { 
        serverPunishVulnerable(vulnerablePlayerIdx); 
        db.collection("rooms").doc(currentRoomId).update({ "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[myPlayerIdx]}">${myName}</b> ƒ∞Tƒ∞RAZ ETTƒ∞ ve kazandƒ±!`, ts: Date.now(), isSystem: true } }); 
    }
    else { 
        serverPunishChallenger(myPlayerIdx); 
        db.collection("rooms").doc(currentRoomId).update({ "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[myPlayerIdx]}">${myName}</b> YANLI≈û ƒ∞Tƒ∞RAZ ETTƒ∞!`, ts: Date.now(), isSystem: true } }); 
    }
}
function playerSendMessage() { let input = document.getElementById('player-input'); let msg = input.value.trim(); if(msg) { db.collection("rooms").doc(currentRoomId).update({ "gameState.lastChat": { sender: myName, msg: msg, ts: Date.now(), isSystem: false }, "lastActive": Date.now() }); input.value = ''; } }

/* --- SERVER ACTIONS --- */
function recycleDeck(discardPile) {
    let cleanDeck = discardPile.map(c => {
        let copy = {...c};
        delete copy.chosenColor; 
        return copy;
    });
    return shuffleDeck(cleanDeck);
}

async function serverDrawCard(pIdx, count, isPenalty = false) {
    let newDeck = [...gameDeck], newDiscard = [...gameDiscard];
    let newHands = gameHands.map(h => [...h]); 
    
    if(newDeck.length < count && newDiscard.length > 1) { 
        let top = newDiscard.pop(); 
        newDeck = recycleDeck(newDiscard); 
        newDiscard = [top]; 
    }
    for(let i=0; i<count; i++) if(newDeck.length > 0) newHands[pIdx].push(newDeck.pop());
    let pUpdates = [...gamePlayers]; pUpdates[pIdx].hand = newHands[pIdx]; pUpdates[pIdx].saidSonTabak = false;
    
    let updates = { "players": pUpdates, "gameState.deck": newDeck, "gameState.discardPile": newDiscard, "gameState.drawStack": 0, "gameState.hasDrawn": true, "gameState.lastAction": { type: 'draw', pIdx, count, timestamp: Date.now() }, "lastActive": Date.now(), "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[pIdx]}">${gamePlayers[pIdx].name}</b> ${count} kart √ßekti.`, ts: Date.now(), isSystem: true } };
    if(isPenalty) {
        updates["gameState.hasDrawn"] = false; 
        updates["gameState.lastChat"].msg += " (Ceza)";
    }
    
    await db.collection("rooms").doc(currentRoomId).update(updates);
}
async function serverPassTurn(pIdx) { await db.collection("rooms").doc(currentRoomId).update({ "gameState.currentPlayer": (currentPlayer + direction + 4) % 4, "gameState.hasDrawn": false, "gameState.vulnerablePlayerIdx": -1, "lastActive": Date.now(), "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[pIdx]}">${gamePlayers[pIdx].name}</b> Pas ge√ßti.`, ts: Date.now(), isSystem: true } }); }

async function serverPlayCard(pIdx, cIdx, cardWithColor, mixerDir = 1, declaredSonTabak = false) {
    let newHands = gameHands.map(h => [...h]); 
    let newDiscard = [...gameDiscard];
    if(!newHands[pIdx] || !newHands[pIdx][cIdx]) return;

    let card = newHands[pIdx][cIdx]; if(cardWithColor) card = cardWithColor;
    
    newHands[pIdx].splice(cIdx, 1); 
    newDiscard.push(card);
    
    let newDir = direction, newDrawStack = drawStack, nextP = currentPlayer, newWinner = -1;
    let playerUpdates = [...gamePlayers]; playerUpdates[pIdx].saidSonTabak = false;
    if(newHands[pIdx].length === 0) newWinner = pIdx;
    
    if(card.val === 'Wild Mixer') { 
        newDir = mixerDir || 1; 
    } else if (card.val === 'Reverse') { 
        newDir *= -1; 
    }

    if(newWinner === -1) { 
        if(card.val === 'Block') nextP = (currentPlayer + (newDir * 2) + 4) % 4; 
        else nextP = (currentPlayer + newDir + 4) % 4; 
    }

    if(card.val === '+1') newDrawStack += 1; if(card.val === '+2') newDrawStack += 2; if(card.val === 'Wild Meze') newDrawStack += 1; if(card.val === 'Wild Anti-Draw') newDrawStack = 0;
    
    if(card.val === 'Wild Table') { 
        let counts = newHands.map(h => h.length); 
        let allCards = []; 
        newHands.forEach(h => { allCards.push(...h); h.length = 0; }); 
        allCards = shuffleDeck(allCards); 
        for(let i=0; i<4; i++) {
            for(let j=0; j<counts[i]; j++) {
                if(allCards.length > 0) newHands[i].push(allCards.pop());
            }
        }
    }
    
    if(card.val === 'Wild Mixer') { 
        if(newDir === 1) { let temp = newHands[3]; newHands[3] = newHands[2]; newHands[2] = newHands[1]; newHands[1] = newHands[0]; newHands[0] = temp; } 
        else { let temp = newHands[0]; newHands[0] = newHands[1]; newHands[1] = newHands[2]; newHands[2] = newHands[3]; newHands[3] = temp; } 
    }
    if(card.val === 'Wild Pot') { 
        for(let k=0; k<4; k++) {
            let targetP = (pIdx + (k * newDir) + 4) % 4; 
            if(gameDeck.length > 0) newHands[targetP].push(gameDeck.pop());
        }
    }
    if(card.val === 'Wild Meze') { let prevP = (pIdx - newDir + 4) % 4; if(gameDeck.length > 0) newHands[prevP].push(gameDeck.pop()); }
    playerUpdates = playerUpdates.map((p, i) => ({...p, hand: newHands[i]}));
    
    let isSafe = gamePlayers[pIdx].saidSonTabak || declaredSonTabak;
    let newVulnerable = (newHands[pIdx].length === 1 && !isSafe) ? pIdx : -1; 
    if(nextP === newVulnerable) newVulnerable = -1;
    
    let cardName = card.type === 'num' ? `${card.val} ${VEGETABLES[card.color]}` : (card.val==='Wild' ? `G√ºve√ß (${VEGETABLES[card.chosenColor]})` : (CARD_NAMES[card.val] || card.val));
    
    let updates = { "players": playerUpdates, "gameState.discardPile": newDiscard, "gameState.currentPlayer": nextP, "gameState.direction": newDir, "gameState.drawStack": newDrawStack, "gameState.vulnerablePlayerIdx": newVulnerable, "gameState.hasDrawn": false, "gameState.lastAction": { type: 'play', pIdx, card, timestamp: Date.now() }, "lastActive": Date.now(), "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[pIdx]}">${gamePlayers[pIdx].name}</b> ${cardName} attƒ±.`, ts: Date.now(), isSystem: true } };
    if(card.val === 'Wild Pot' || card.val === 'Wild Meze' || card.val === 'Wild Table') updates["gameState.deck"] = gameDeck;
    if(newWinner !== -1) { updates["gameState.gameActive"] = false; updates["gameState.winnerIdx"] = newWinner; let roundScores = newHands.map(h => h.reduce((sum, c) => sum + (c.type==='num'?parseInt(c.val):20), 0)); updates["players"] = playerUpdates.map((p, i) => ({ ...p, score: p.score + roundScores[i] })); }
    await db.collection("rooms").doc(currentRoomId).update(updates);
}
async function serverPunishVulnerable(victimIdx) { 
    let newDeck = [...gameDeck], newHands = gameHands.map(h=>[...h]), c = newDeck.pop(); if(c) newHands[victimIdx].push(c); let pUpdates = [...gamePlayers]; pUpdates[victimIdx].hand = newHands[victimIdx]; 
    await db.collection("rooms").doc(currentRoomId).update({ "players": pUpdates, "gameState.deck": newDeck, "gameState.vulnerablePlayerIdx": -1, "gameState.lastAction": { type: 'challenge', success: true, victimIdx: victimIdx, timestamp: Date.now() } }); 
}
async function serverPunishChallenger(challengerIdx) { 
    let newDeck = [...gameDeck], newHands = gameHands.map(h=>[...h]), c = newDeck.pop(); if(c) newHands[challengerIdx].push(c); let pUpdates = [...gamePlayers]; pUpdates[challengerIdx].hand = newHands[challengerIdx]; pUpdates[challengerIdx].challengeUsed = true; let nextP = (currentPlayer + direction + 4) % 4; 
    await db.collection("rooms").doc(currentRoomId).update({ "players": pUpdates, "gameState.deck": newDeck, "gameState.currentPlayer": nextP, "gameState.hasDrawn": false, "gameState.lastAction": { type: 'challenge', success: false, victimIdx: challengerIdx, timestamp: Date.now() } }); 
}

async function nextRound() {
    if(!isHost) return;
    document.getElementById('end-modal').style.display = 'none';
    const newDeck = createFullDeck();
    const hands = [[], [], [], []];
    for(let i=0; i<7; i++) { for(let p=0; p<4; p++) hands[p].push(newDeck.pop()); }
    const updatedPlayers = gamePlayers.map((p, i) => ({ ...p, hand: hands[i], isReady: false, saidSonTabak: false, challengeUsed: false }));
    let first = newDeck.pop(); while(first.color === 'wild' || first.type === 'action') { newDeck.unshift(first); first = newDeck.pop(); }
    const nextState = { deck: newDeck, discardPile: [first], currentPlayer: lastWinner, direction: 1, drawStack: 0, gameActive: true, lastAction: { type: 'newRound', timestamp: Date.now() }, vulnerablePlayerIdx: -1, playerColors: playerColors, lastChat: { sender: "Sistem", msg: "Yeni El Ba≈üladƒ±!", ts: Date.now(), isSystem: true }, hasDrawn: false };
    await db.collection("rooms").doc(currentRoomId).update({ players: updatedPlayers, gameState: nextState, lastActive: Date.now() });
}

async function hostBotTurn() {
    try {
        if(!isHost) return;
        const currentPObj = gamePlayers[currentPlayer];
        if(!currentPObj || !currentPObj.isBot) return; 

        const triggerChat = async (cat) => {
            let pType = currentPObj.personality || 'Dengeli';
            let pool = CHAT_POOL[pType] || CHAT_POOL['Dengeli'];
            let msgs = pool[cat] || pool['draw_many'];
            let msg = msgs[Math.floor(Math.random()*msgs.length)];
            db.collection("rooms").doc(currentRoomId).update({
                "gameState.lastChat": { sender: currentPObj.name, msg: msg, ts: Date.now(), isSystem: false }
            }).catch(e => console.log("Chat error", e));
        };

        if(vulnerablePlayerIdx !== -1 && vulnerablePlayerIdx !== currentPlayer) {
            if(Math.random() < 0.95) { 
                await serverPunishVulnerable(vulnerablePlayerIdx);
                await db.collection("rooms").doc(currentRoomId).update({ 
                    "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${playerColors[currentPlayer]}">${currentPObj.name}</b> uyanƒ±klƒ±k yaptƒ± ve itiraz etti!`, ts: Date.now(), isSystem: true } 
                });
                await wait(1500); 
            }
        }

        const hand = gameHands[currentPlayer];
        let playableIdx = -1;
        let willSaySonTabak = false;
        
        if(drawStack > 0) {
            playableIdx = hand.findIndex(c => c.val === '+2' || (c.val === '+1' && gameDiscard[gameDiscard.length-1].val==='+1') || c.val === 'Wild Meze' || c.val === 'Wild Anti-Draw');
        } else {
            playableIdx = hand.findIndex(c => canPlay(c));
        }

        if(playableIdx !== -1 && hand.length === 2) {
             if(Math.random() > 0.1) {
                 await serverBotSaySonTabak(currentPlayer); 
                 willSaySonTabak = true;
             }
        }

        if (drawStack > 0 && playableIdx === -1) {
            triggerChat("draw_many");
            await serverDrawCard(currentPlayer, drawStack, true); 
            setTimeout(() => serverPassTurn(currentPlayer), 1000); 
            return;
        }

        if(playableIdx !== -1) {
            let card = hand[playableIdx];
            if(card.color === 'wild') {
                triggerChat("wild");
                card.chosenColor = ['red','green','yellow','purple'][Math.floor(Math.random()*4)];
            }
            if(card.val === '+2') triggerChat("plus2");
            if(card.val === 'Block') triggerChat("block");
            
            if(card.val === 'Wild Mixer') await serverPlayCard(currentPlayer, playableIdx, card, 1, willSaySonTabak); 
            else await serverPlayCard(currentPlayer, playableIdx, card, 1, willSaySonTabak);
        } else {
            if(!hasDrawn) await serverDrawCard(currentPlayer, 1);
            else await serverPassTurn(currentPlayer);
        }
    } catch(e) {
        console.error("Bot Logic Error:", e);
        throw e;
    }
}

async function serverBotSaySonTabak(pIdx) {
    let pUpdates = [...gamePlayers]; pUpdates[pIdx].saidSonTabak = true;
    let pColor = playerColors[pIdx];
    await db.collection("rooms").doc(currentRoomId).update({ players: pUpdates, "gameState.vulnerablePlayerIdx": -1, "gameState.lastAction": { type: 'sonTabak', pIdx: pIdx, timestamp: Date.now() }, "gameState.lastChat": { sender: "Sistem", msg: `<b style="color:${pColor}">${gamePlayers[pIdx].name}</b> SON TABAK dedi!`, ts: Date.now(), isSystem: true } });
}

/* --- YARDIMCI G√ñRSELLER & ANƒ∞MASYONLAR --- */
function updateUI() {
    if(myPlayerIdx === -1) return;
    let aL = document.getElementById('arrow-left'), aR = document.getElementById('arrow-right'), aT1 = document.getElementById('arrow-top-1'), aT2 = document.getElementById('arrow-top-2');
    aL.className = 'arrow-icon'; aR.className = 'arrow-icon'; aT1.className = 'arrow-top-static'; aT2.className = 'arrow-top-static';

    if(direction === 1) { aL.innerText = '‚¨ÜÔ∏è'; aR.innerText = '‚¨áÔ∏è'; aT1.innerText = '‚û°Ô∏è'; aT2.innerText = '‚û°Ô∏è'; } else { aL.innerText = '‚¨áÔ∏è'; aR.innerText = '‚¨ÜÔ∏è'; aT1.innerText = '‚¨ÖÔ∏è'; aT2.innerText = '‚¨ÖÔ∏è'; }
    if(gameActive) {
        let topCard = gameDiscard[gameDiscard.length-1]; let activeColor = topCard ? (topCard.chosenColor || topCard.color) : null; if(activeColor === 'wild') activeColor = 'neutral';
        let glowClass = activeColor ? `glow-${activeColor}` : '';
        let relCurrent = (currentPlayer - myPlayerIdx + 4) % 4, relNext = ((currentPlayer+direction+4)%4 - myPlayerIdx + 4) % 4;
        let tArr = null;
        if((relCurrent===0 && relNext===1) || (relCurrent===1 && relNext===0)) tArr = aL;
        if((relCurrent===1 && relNext===2) || (relCurrent===2 && relNext===1)) tArr = aT1;
        if((relCurrent===2 && relNext===3) || (relCurrent===3 && relNext===2)) tArr = aT2;
        if((relCurrent===3 && relNext===0) || (relCurrent===0 && relNext===3)) tArr = aR;
        if(tArr && glowClass) tArr.classList.add('active', glowClass);
    }

    if(gameDeck) document.getElementById('deck-count').innerText = gameDeck.length;
    let pBadge = document.getElementById('penalty-badge');
    if(drawStack > 0) { pBadge.innerText = "+" + drawStack; pBadge.style.display = 'flex'; pBadge.className = `p-${Math.min(drawStack,6)}`; } else pBadge.style.display = 'none';

    let sortedP = [...gamePlayers].sort((a,b)=>a.score - b.score);
    let html = "";
    sortedP.forEach(p => {
         let color = playerColors[gamePlayers.findIndex(x => x.uid===p.uid)] || '#333';
         let isMe = p.uid === myUid;
         html += `<tr class="${isMe?'me-row':''}"><td style="color:${color}; font-weight:${isMe?'900':'normal'};">${p.name}</td><td style="text-align:right;">${p.score}</td></tr>`;
    });
    document.getElementById('score-table').querySelector('tbody').innerHTML = html;

    let dp = document.getElementById('discard-pile');
    if(gameDiscard.length > 0) {
        let c = gameDiscard[gameDiscard.length-1];
        dp.innerHTML = createCardHTML(c);
        let activeColor = c.chosenColor || c.color;
        let cont = document.querySelector('.game-container');
        cont.classList.remove('ambient-red', 'ambient-green', 'ambient-yellow', 'ambient-purple');
        if(activeColor !== 'wild') cont.classList.add(`ambient-${activeColor}`);
    }

    if (!isDealing) {
        let ph = document.getElementById('player-hand'); ph.innerHTML = '';
        if(currentPlayer === myPlayerIdx) ph.classList.add('current-player-area'); else ph.classList.remove('current-player-area');
        gameHands[myPlayerIdx].forEach((c, idx) => {
            let div = document.createElement('div'); div.innerHTML = createCardHTML(c); let el = div.firstElementChild;
            if(currentPlayer === myPlayerIdx && canPlay(c)) { el.classList.add('playable'); el.onclick = () => playerPlayCard(idx); } else el.style.opacity = 0.6;
            ph.appendChild(el);
        });
    }

    const visualIndices = [ (myPlayerIdx + 1) % 4, (myPlayerIdx + 2) % 4, (myPlayerIdx + 3) % 4 ];
    for(let i=0; i<3; i++) {
        let realIdx = visualIndices[i]; let p = gamePlayers[realIdx]; let elId = `bot${i+1}`;
        if(p) {
            let pColor = playerColors[realIdx] || '#333';
            document.getElementById(`${elId}-name`).innerHTML = `<span style="color:${pColor}">${p.name}</span> (${p.hand.length})`;
            let stack = document.getElementById(`${elId}-stack`); stack.innerHTML = "";
            let visibleCount = Math.min(p.hand.length, 6);
            let totalW = 60 + (visibleCount > 0 ? (visibleCount-1)*8 : 0);
            stack.style.width = totalW + 'px';
            for(let j=0; j<visibleCount; j++) {
                let mc = document.createElement('div'); mc.className = 'mini-card-back'; mc.style.top = (j*4)+'px'; mc.style.left = (j*8)+'px'; stack.appendChild(mc);
            }
            if(currentPlayer === realIdx) document.getElementById(`${elId}-wrapper`).classList.add('current-player'); else document.getElementById(`${elId}-wrapper`).classList.remove('current-player');
        }
    }

    let stBtn = document.getElementById('son-tabak-btn');
    stBtn.disabled = !(currentPlayer === myPlayerIdx && gameHands[myPlayerIdx].length <= 2 && !gamePlayers[myPlayerIdx].saidSonTabak);
    let chBtn = document.getElementById('challenge-btn');
    chBtn.disabled = !(currentPlayer === myPlayerIdx && !gamePlayers[myPlayerIdx].challengeUsed);
}

function animateFly(from, to, html, callback) {
    if(!from || !to) { if(callback) callback(); return; }
    let f = from.getBoundingClientRect(); let t = to.getBoundingClientRect();
    let el = document.createElement('div');
    if(html) { let w = document.createElement('div'); w.innerHTML = html; el = w.firstElementChild; el.classList.add('flying-card'); } else { el.className = 'card card-back-style flying-card'; }
    
    // START CENTERED
    let startX = f.left + f.width/2 - 52; // 52 = cardWidth/2
    let startY = f.top + f.height/2 - 77; // 77 = cardHeight/2
    
    // END CENTERED
    let endX = t.left + t.width/2 - 52; 
    let endY = t.top + t.height/2 - 77;
    
    el.style.left = startX + 'px'; 
    el.style.top = startY + 'px'; 
    document.body.appendChild(el);
    
    void el.offsetWidth; // Force Reflow
    
    el.style.left = endX + 'px'; 
    el.style.top = endY + 'px'; 
    
    setTimeout(() => { el.remove(); if(callback) callback(); }, ANIM_CONFIG.FLY_BUFFER);
}
function animateReverse() { 
    return new Promise(resolve => {
        document.querySelectorAll('.arrow-icon').forEach(el => { el.classList.add('arrow-spin'); });
        document.querySelectorAll('.arrow-top-static').forEach(el => { el.classList.add('arrow-spin'); });
        setTimeout(() => { 
            document.querySelectorAll('.arrow-icon').forEach(el => { el.classList.remove('arrow-spin'); }); 
            document.querySelectorAll('.arrow-top-static').forEach(el => { el.classList.remove('arrow-spin'); }); 
            resolve(); 
        }, 1200);
    });
}
function animateBlock(pIdx) {
    let victimIdx = (pIdx + direction + 4) % 4;
    let targetId = victimIdx === myPlayerIdx ? 'player-hand' : `bot${(victimIdx - myPlayerIdx + 4) % 4}-wrapper`;
    let el = document.getElementById(targetId);
    if(el) {
        let b = document.createElement('div'); b.innerText = 'üî™'; b.className = 'blocked-anim';
        let r = el.getBoundingClientRect(); b.style.left = r.left+(r.width/2)+'px'; b.style.top = r.top+(r.height/2)+'px';
        document.body.appendChild(b); setTimeout(()=>b.remove(),2000);
    }
}
function animateTableEffect() {
    return new Promise(resolve => {
        let centerEl = document.getElementById('play-area'); let rect = centerEl.getBoundingClientRect();
        let centerX = rect.left + rect.width/2; let centerY = rect.top + rect.height/2;
        let animCards = [];
        ['player-hand','bot1-wrapper','bot2-wrapper','bot3-wrapper'].forEach(id => {
            let el = document.getElementById(id); if(el) {
                let r = el.getBoundingClientRect();
                for(let k=0; k<3; k++) {
                    let ac = document.createElement('div'); ac.className = 'mini-card-back'; 
                    ac.style.zIndex = 5000; ac.style.left = r.left + 'px'; ac.style.top = r.top + 'px';
                    document.body.appendChild(ac); animCards.push(ac);
                }
            }
        });
        setTimeout(() => {
            animCards.forEach(ac => { ac.style.transition = 'all 1.2s ease-in-out'; ac.style.left = (centerX - 30) + 'px'; ac.style.top = (centerY - 45) + 'px'; ac.style.transform = 'rotate(720deg)'; });
        }, 50);
        setTimeout(() => { 
            animCards.forEach(ac => { let angle = Math.random() * Math.PI * 2; let dist = 400; ac.style.left = (centerX + Math.cos(angle)*dist) + 'px'; ac.style.top = (centerY + Math.sin(angle)*dist) + 'px'; ac.style.opacity = 0; });
            setTimeout(() => { animCards.forEach(ac => ac.remove()); resolve(); }, 1200);
        }, 1500);
    });
}
function animateMixerEffect(dir) {
    return new Promise(resolve => {
        let dp = document.getElementById('play-area'); let rect = dp.getBoundingClientRect();
        let cx = rect.left + rect.width/2; let cy = rect.top + rect.height/2;
        let mixerContainer = document.createElement('div'); mixerContainer.className = 'mixer-container'; mixerContainer.style.left = cx + 'px'; mixerContainer.style.top = cy + 'px';
        document.body.appendChild(mixerContainer);
        for(let i=0; i<8; i++) {
            let c = document.createElement('div'); c.className = 'mixer-card card-back-style'; c.style.transform = `rotate(${(i/8)*360}deg) translateY(-70px)`; mixerContainer.appendChild(c);
        }
        setTimeout(() => { mixerContainer.style.transition = 'transform 2s ease-in-out'; mixerContainer.style.transform = `rotate(${dir * 720}deg)`; }, 100);
        setTimeout(() => { mixerContainer.remove(); resolve(); }, 2200);
    });
}
function animatePotEffect(senderIdx, dir) {
    let source = document.getElementById('draw-pile');
    for(let k=0; k<4; k++) {
        let targetPIdx = (senderIdx + (k * dir) + 4) % 4;
        let targetId = targetPIdx === myPlayerIdx ? 'player-hand' : `bot${(targetPIdx - myPlayerIdx + 4) % 4}-wrapper`;
        setTimeout(() => { 
            animateFly(source, document.getElementById(targetId), null); 
        }, k * ANIM_CONFIG.DRAW_INTERVAL);
    }
}
function animateMezeEffect(senderIdx) {
    let prevIdx = (senderIdx - direction + 4) % 4;
    let targetId = prevIdx === myPlayerIdx ? 'player-hand' : `bot${(prevIdx - myPlayerIdx + 4) % 4}-wrapper`;
    animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), null);
}
async function animateInitialDeal() {
    let piles = [];
    isDealing = true; 
    document.getElementById('player-hand').innerHTML = '';
    
    let targets = ['player-hand', 'bot1-wrapper', 'bot2-wrapper', 'bot3-wrapper'];
    let myHandClone = [...gameHands[myPlayerIdx]]; 
    let myCardIndex = 0;

    for(let round=0; round<7; round++) {
        for(let p=0; p<4; p++) {
            let targetId = targets[p];
            let cardHtml = null;
            if (p === 0 && myCardIndex < myHandClone.length) {
                cardHtml = createCardHTML(myHandClone[myCardIndex]);
            }

            animateFly(document.getElementById('draw-pile'), document.getElementById(targetId), cardHtml, () => {
                if (p === 0 && cardHtml) {
                    let div = document.createElement('div'); 
                    div.innerHTML = cardHtml; 
                    let el = div.firstElementChild;
                    el.style.opacity = 0.6; 
                    document.getElementById('player-hand').appendChild(el);
                }
            });
            if(p===0) myCardIndex++;
            await wait(ANIM_CONFIG.INITIAL_DEAL); 
        }
    }
    // Clean up temporary cards before final render to avoid duplication
    document.getElementById('player-hand').innerHTML = '';
    isDealing = false; 
    updateUI();
}
function startVegetableRain() {
    const canvas = document.getElementById('confetti-canvas'); const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const emojis = ['ü•¶', 'üçÖ', 'ü•î', 'üçÜ']; let drops = [];
    for(let i=0; i<30; i++) drops.push({x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20});
    let isActive = true; setTimeout(() => isActive=false, 4000);
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(isActive && Math.random() < 0.3) drops.push({x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20});
        for (let i = 0; i < drops.length; i++) {
            let d = drops[i]; ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.rot * Math.PI / 180); ctx.font = `${d.size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(d.emoji, 0, 0); ctx.restore();
            d.y += d.vy; d.x += d.vx + Math.sin(d.y / 50) * 0.5; d.rot += d.rotSpeed;
            if (d.y > canvas.height + 50) { if(isActive) drops[i] = {x:Math.random()*canvas.width, y:-50, vy:Math.random()*3+2, vx:Math.random()*2-1, rot:Math.random()*360, rotSpeed:(Math.random()-0.5)*5, emoji:emojis[Math.floor(Math.random()*4)], size:Math.random()*20+20}; else { drops.splice(i, 1); i--; } }
        }
        if (drops.length > 0 || isActive) requestAnimationFrame(animate); else ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    animate();
}

function openRules() { document.getElementById('rules-modal').style.display = 'flex'; }
// LEAVE GAME FIX
function leaveGame() { document.getElementById('leave-modal').style.display = 'flex'; }
function confirmLeaveGame() {
    if(!currentRoomId) return; 
    db.collection("rooms").doc(currentRoomId).get().then(doc => {
        if(!doc.exists) { location.reload(); return; }
        let ps = doc.data().players || [];
        let rData = doc.data();
        let isPlaying = rData.status === 'playing';

        if(ps.length <= 1) {
            db.collection("rooms").doc(currentRoomId).delete()
                .then(() => location.reload())
                .catch(() => location.reload());
        } else {
            let newPs;
            if(isPlaying) {
                newPs = ps.map(p => {
                    if(p.uid === myUid) {
                        return {
                            ...p,
                            uid: 'replaced_bot_' + Date.now(),
                            name: 'ü§ñ ' + p.name,
                            isBot: true,
                            isReady: true,
                            personality: 'Agresif',
                            lastSeen: Date.now()
                        };
                    }
                    return p;
                });
            } else {
                newPs = ps.filter(p => p.uid !== myUid);
            }
            
            db.collection("rooms").doc(currentRoomId).update({ players: newPs })
                .then(() => location.reload())
                .catch(() => location.reload());
        }
    });
}

/* --- UTILS --- */
const VEGETABLES = { red: 'üçÖ', green: 'ü•¶', yellow: 'ü•î', purple: 'üçÜ' };
const SPECIALS = { '+1': 'üì¶', '+2': 'üì¶üì¶', 'Reverse': '‚ôªÔ∏è', 'Block': 'üî™', 'Wild': 'GUVEC', 'Wild Anti-Draw': 'üßª', 'Wild Pot': 'üç≤', 'Wild Table': 'üçΩÔ∏è', 'Wild Mixer': 'üå™Ô∏è', 'Wild Meze': 'üç±' };
function createCardHTML(card) {
    let emoji = (card.type === 'num') ? VEGETABLES[card.color] : (card.val === 'Wild' ? `<div class="guvec-grid"><span>üçÖ</span><span>ü•¶</span><span>ü•î</span><span>üçÜ</span></div>` : (SPECIALS[card.val] || card.val));
    let cls = (card.color === 'wild') ? 'wild-bg' : card.color;
    let borderStyle = card.chosenColor ? `border-color: ${card.chosenColor==='red'?'#e74c3c':card.chosenColor==='green'?'#2ecc71':card.chosenColor==='yellow'?'#f39c12':'#9b59b6'} !important; border-width: 3px;` : '';
    // CSS Variable handles background
    let cornerTxt = (card.type === 'num') ? card.val : '';
    return `<div class="card ${cls}" style="${borderStyle}"><div class="card-corner top-left">${cornerTxt}</div><div class="card-emoji">${emoji}</div><div class="card-corner bottom-right">${cornerTxt}</div></div>`;
}
function toggleInfoView(el) { el.classList.toggle('flipped'); }
function openPatternModal() { 
    const grid = document.getElementById('pattern-grid'); grid.innerHTML = ''; 
    CARD_PATTERNS.forEach(p => { 
        let d = document.createElement('div'); 
        d.className = 'pattern-opt'; 
        d.style.background = p; 
        d.onclick = () => { 
            // CHANGE CSS VARIABLE
            document.documentElement.style.setProperty('--card-pattern', p);
            currentPattern = p; 
            updateUI(); 
            closePatternModal(); 
        }; 
        grid.appendChild(d); 
    }); 
    document.getElementById('pattern-modal').style.display = 'flex'; 
}
function closePatternModal() { document.getElementById('pattern-modal').style.display = 'none'; }
function handleChatKey(e) { if(e.key === 'Enter') playerSendMessage(); }
function toggleReadyState() { if(!currentRoomId) return; amIReady = !amIReady; let btn = document.getElementById('end-continue-btn'); btn.innerText = amIReady ? "Bekleniyor..." : "Devam Et ‚è≥"; btn.classList.toggle('btn-blue'); btn.classList.toggle('btn-dark'); let ps = [...gamePlayers]; let meIdx = ps.findIndex(p => p.uid === myUid); if(meIdx !== -1) { ps[meIdx].isReady = amIReady; db.collection("rooms").doc(currentRoomId).update({ players: ps, lastActive: Date.now() }); } }

const cleanupRoom = async () => { if(heartbeatInterval) clearInterval(heartbeatInterval); };

function shuffleDeck(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
function createFullDeck() { let d = []; ['red','green','yellow','purple'].forEach(c => { d.push({color:c,val:'0',type:'num',name:'0'}); for(let i=1; i<=9; i++) d.push({color:c,val:i.toString(),type:'num',name:i}); ['+1','Reverse','Block'].forEach(v=>d.push({color:c,val:v,type:'action',name:v})); }); for(let i=0;i<2;i++) { d.push({color:'wild',val:'Wild',type:'wild',name:'G√ºve√ß'}); d.push({color:'wild',val:'+2',type:'wild',name:'+2'}); d.push({color:'wild',val:'Wild Anti-Draw',type:'wild',name:'Tuvalet Kaƒüƒ±dƒ±'}); d.push({color:'wild',val:'Wild Pot',type:'wild',name:'D√ºd√ºkl√º Tencere'}); d.push({color:'wild',val:'Wild Meze',type:'wild',name:'Meze'}); } d.push({color:'wild',val:'Wild Table',type:'wild',name:'Sofra'}); d.push({color:'wild',val:'Wild Mixer',type:'wild',name:'Mikser'}); return shuffleDeck(d); }
function showSonTabakPopup(name) { let p = document.getElementById('son-tabak-popup'); document.getElementById('son-tabak-who').innerText = name + " dedi!"; p.style.display = 'block'; setTimeout(() => p.style.display = 'none', ANIM_CONFIG.POPUP); }
function showChallengePopup(success, title, detail) { 
    let p = document.getElementById('challenge-popup'); 
    document.getElementById('challenge-who').innerText = title || "ƒ∞Tƒ∞RAZ!"; 
    document.getElementById('challenge-result').innerText = detail || (success ? "BA≈ûARILI! ‚úÖ" : "HATALI! ‚ùå"); 
    p.className = success ? 'challenge-valid' : 'challenge-invalid'; 
    p.style.display = 'block'; 
    setTimeout(() => p.style.display = 'none', ANIM_CONFIG.POPUP); 
}
function addSystemLog(html) { const logList = document.getElementById('system-log'); const li = document.createElement('li'); li.innerHTML = html; logList.prepend(li); }
function addChatLog(name, msg, color) { const chatDiv = document.getElementById('chat-messages'); const msgDiv = document.createElement('div'); msgDiv.className = `chat-line`; msgDiv.innerHTML = `<span class="chat-name" style="color:${color}; font-weight:bold;">${name}:</span><span class="chat-text">${msg}</span>`; chatDiv.appendChild(msgDiv); chatDiv.scrollTop = chatDiv.scrollHeight; }
function showToast(msg) { let t = document.getElementById('toast'); t.innerText = msg; t.style.display = 'block'; setTimeout(() => t.style.display = 'none', ANIM_CONFIG.TOAST); }
function showEndGame(winnerIdx, finalPlayers) {
    lastWinner = winnerIdx;
    const winnerName = finalPlayers[winnerIdx].name;
    document.getElementById('winner-text').innerText = `üéâ ${winnerName} Kazandƒ±!`;
    document.getElementById('ai-summary').innerHTML = `üé§ <b>Spiker:</b> "Vay vay vay! ${winnerName} resmen masayƒ± s√ºp√ºrd√º!"`;
    document.getElementById('end-modal').style.display = 'flex';
    updateReadyStatusUI(); startVegetableRain(); SoundFX.playFanfare();
}
function updateReadyStatusUI() {
    let allReady = true; gamePlayers.forEach(p => { if(!p.isBot && !p.isReady) allReady = false; });
    let sortedP = [...gamePlayers].sort((a,b)=>a.score - b.score);
    let html = `<table style="width:100%; border-collapse:collapse;">`; 
    sortedP.forEach(p => { 
        let isMe = p.uid === myUid; 
        let pColor = playerColors[gamePlayers.findIndex(x=>x.uid===p.uid)] || '#333';
        html += `<tr style="${isMe ? 'background-color: #fff9c4; font-weight: bold; border-left: 4px solid #f1c40f;' : ''}">
                    <td style="padding: 8px 10px; border-bottom: 1px solid #eee; color:${pColor};">${p.name}</td>
                    <td style="padding: 8px 10px; border-bottom: 1px solid #eee; text-align:right;">${p.score} ${(p.isReady||p.isBot)?'‚úÖ':'‚è≥'}</td>
                 </tr>`; 
    });
    html += `</table>`;
    document.getElementById('final-scores').innerHTML = html;
    if(isHost) document.getElementById('host-start-btn').style.display = allReady ? 'block' : 'none';
}
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
</script>
</body>
</html>
